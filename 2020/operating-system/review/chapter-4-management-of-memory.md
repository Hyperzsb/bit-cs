# 第4章 - 存储器管理

### 概述

1. **存储器管理涉及的功能**

   - 存储器分配：主要解决多道程序或多进程如何共享主存的问题
   - 地址转换或重定位：研究各种地址变换方法及响应的地址变换机构
   - 存储器保护：研究如何防止故障程序破坏操作系统和存储器内的其他各种信息
   - 存储器扩充：研究采用多级存储技术实现虚拟存储器及所用的各种管理算法
   - 存储器共享：研究并发执行的进程如何共享主存中的程序和数据问题

2. **地址空间（Address Space）**

   由于程序在主存中的位置是不可预知的，编译或汇编时，程序中各个地址总是以“0”作为参考地址，其他所有地址都是以0作为起始地址顺序编码的。因此把程序限定空间叫做逻辑地址空间，其中的地址叫做相对地址或逻辑地址。程序的地址空间的大小由被编译和链接后的程序大小决定

3. **存储空间（Memory Space）**

   存储空间是指物理存储器中全部物理单元的集合所限定的空间。它是由字或字节组层的一个大的阵列，每个字或字节都有它自己的编号，这些编号就叫做物理地址或绝对地址，又叫实地址。存储空间的大小由系统的硬件配置决定。一个程序只有从地址空间装入到存储空间后才能运行

4. **地址重定位（Address Relocation）**

   - 程序的链接：

     链接程序的功能就是将编译/汇编产生的一个或多个目标代码与所需要的库函数装配成一个可执行映像（程序）。程序的链接方式有两种：

     - 静态链接：在程序装入内存运行之间，就将目标模块与语言支持的库例程事先链接成为可执行程序
     - 动态链接：又分为装入时和运行时两种。采用装入时的动态链接就是将各目标程序模块装入主存，边装入边链接；采用运行时的动态链接就是对目标模块的链接一直推迟到程序运行时才进行链接。与装入时的动态链接比较，其好处就是便于模块的共享，且它使系统空间和时间上的开销最小，系统效率最高

   - 地址重定位：显然静态链接后映像形成的是一个一维的地址域，该地址就叫该程序的地址空间。该域中的各个地址就叫做该程序的线性地址或虚地址。当要将用户程序装入主存运行时，首先要为它分配一个适当大小的存储区域。程序使用的时逻辑或线性地址，这些地址往往与分配到的存储空间的地址是不同的。把程序的地址空间的逻辑地址转换为存储空间的物理地址的工作叫做地址重定位，又叫做地址映射或地址变换（Address Mapping）。实现由虚地址映射到物理地址的工作是由叫做存储器管理单元（Memory Management Unit, MMU）的硬件实现的

   - 静态重定位（Static Relocation）：

     在装入进程时，由装入程序把用户程序中的指令和数据地址全部转换成存储空间的绝对地址。由于地址转换工作是在程序执行前集中一次完成的，这样在程序执行时就无须再进行地址转换工作

     一旦要改变程序在主存的位置，必须重新装入一次。显然，采用静态链接或装入时的动态链接方法是通过静态重定位程序完成地址重定位的

     静态重定位不需要硬件支持，因而容易实现。但静态重定位要求程序占有连续的存储区，而且程序在执行时不允许在主存移动。这显然只能用于早期的单道批处理或单任务系统中

   - 动态重定位（Dynamic Relocation）：

     动态重定位是靠硬件的地址转换机构来实现的。通常采用的办法是设置一个重定位寄存器。在将程序装入到存储区后，把这个存储区的起始地址送入重定位寄存器中。在程序执行时，对于每一个存储器的访问，都要将相对地址转换成主存的绝对地址

     这种方式允许程序在主存中移动，此时只要用新地址修改重定位寄存器即可

     相比静态重定位的优点：

     - 主存利用充分
     - 允许程序不必占有连续的存储区域
     - 便于多用户共享存储器中的同一程序和数据

5. **存储器保护（Memory Protection）**

   存储器通常划分为两部分：一部分是操作系统占用区，一部分是多用户进程分享的用户占用区。存储器管理就是对用户占用区的管理

   存储器保护涉及两个方面内容：地址越界和存取方式的保护

6. **存储器共享（Memory Sharing）**

   为提高存储器的利用率，允许多个进程共享一个主存区，这个被共享的主存区既可以是数据，也可以是程序，只是各个进程应进行受控的存储器访问。被共享的程序又叫做可重入程序，其代码在执行过程中不会被修改。具有这种性质的程序又叫纯代码

### 单用户单道程序的存储器分配

最简单的存储器管理方案是单一连续区分配。用在早期的单道批处理和现代的个人计算机的单用户单任务系统中。主存只有一个用户作业，系统把程序从磁盘或磁带上装入主存，并独占全部用户区和所有系统资源

整个系统的资源利用率较低

### 多用户多道程序的存储器分配——分区分配

1. **固定式分区**

   是适合多道程序运行的最简单的存储器管理，它把主存用户空间预先划分成几个大小不等的分区，当进程到达时，选择一个适合进程要求的最小空闲分区分给进程，没有适合的空闲分区时，让其等待:book:

   为实现固定式分区管理，系统通常设置一个分区说明表，用以描述主存各分区的情况:book:

   采用这种技术，方法简单，易于实现。虽然可使多个进程共享主存，但主存的利用是不充分的。因为进程的大小不可能刚好等于划分的分区大小

2. **可变式分区**

   为了提高存储器的利用率，存储空间的划分推迟到转入进程时进行。当进程要求运行时，系统从空闲的存储空间划分出大小正好等于进程大小的一个存储区分配给进程

   管理分区使用的数据结构：

   - 分区说明表：

     为方便主存的分配和回收，分区说明表可由两张表格组成。一张是已分配区表，记录已分配给进程的分区情况；另一张是未分配区表，记录主存空闲区的情况

     当有进程要求分配主存时，首先按照某种算法从未分配区表中找一个足以容纳该进程大小的空闲区，若这个分区比较大，则一分为二，一部分分配给进程，另一部分仍作为空闲区留在表中。再在已分配区表中找一个空表目，填入进程分配的响应信息

     采用分区说明表比较直观、简单，但由于主存分区个数不定，所以表格长度应设置合理，否则会造成浪费，或造成表格溢出

   - 空闲区链:book:

   分配算法：

   - 首次适应法（First Fit）：空闲区表或空闲区链中的空闲区按照起始地址从小到大排列。当进程要求装入主存时，存储分配程序从起始地址最小的空闲区开始扫描，直到找到一个足够大的空闲区，然后将该空闲区分配给进程，剩余的部分继续保留在队列中
   - 最佳适应法（Best Fit）：存储分配程序要扫描表或链中所有的空闲区，直到找到能满足进程要求且为最小的空闲区为止
   - 最坏适应法（Worst Fit）：存储分配程序要扫描表或链中所有的空闲区，直到找到能满足进程要求且为最大的空闲区为止。之后，把这个最大的空闲区一分为二，一部分分给进程，另一部分仍留在链中。其想法在于使剩下的空闲区仍能分配给其他进程。但这样一来，一旦有一个更大进程要求分配时，可能没有一个空闲区能满足要求而过早阻塞在存储器之外
   - 为提高分配存储区的速度，对最佳适应法和最坏适应法进行改进，使空闲区按其尺寸分别从小到大和从大到小排列，从而使最佳、最坏适应法的查找速度与首次适应法一样高效。但每当分配一个空闲区，且有一部分剩余空闲空间时，要重新进行表或链的整理以遍按序排列，从而增加了系统的开销

   当系统回收一个释放区时，要考虑它是否有邻接的空闲区。若有，要进行合并，再将合并后的空闲区插入空闲区表或链的适当位置中:book:

3. **分区管理的地址重定位和存储器保护**

   通常固定式分区采用静态重定位。当采用静态重定位方式装入进程时，系统通常设置两个界限寄存器来实现存储器的保护。上界为进程在主存区的最高地址，下界为进程在主存区的起始地址

   对于可变式分区，采用动态重定位。为此，系统设置一个基址寄存器，存放运行进程的主存区起始地址；再增设一个限长寄存器，用来存放运行程序的大小

4. **分区管理的优缺点**

   优点为：

   - 实现多道程序共享主存
   - 实现分区管理的系统设计相对简单，不需要更多的软硬件开销
   - 实现存储器保护的手段也比较简单

   缺点为：

   - 主存利用不够充分：系统中总有一部分存储空间得不到利用，这部分被浪费的空间叫碎片（或零头）。要克服碎片，可以采用拼接技术，将已分配区的信息移动，使空闲区进行合并。但这将花费大量的 CPU 开销。另外，无法实现多进程共享存储器的信息
   - 没有实现主存的扩充问题。当进程的地址空间大于存储空间时，进程无法运行，也即进程的地址空间受实际存储空间的限制

### 覆盖与交换技术

1. **覆盖（Overlay）**

   是指同一主存区可以被一个或多个作业（或进程）的不同程序段重复使用。通常一个进程由若干个功能上相互独立的程序段组成，进程在一次运行时，也只用到其中的几段。利用这样一个事实，就可以让那些不会同时执行的程序段公用同一个主存区。为此，把可以公用同一个主存区的相互覆盖的程序段叫做覆盖段。而把它们共享的主存区叫做覆盖区。覆盖段与覆盖区一一对应

   为了实现覆盖管理，系统必须提供响应的覆盖管理控制程序。当进程装入运行时，由系统根据用户提供的覆盖结构进行覆盖处理

   覆盖技术的关键是提供正确的覆盖结构。通常，一个进程的覆盖结构要求编程人员事先给出。对于一个规模较大或比较复杂的程序来说是难以分析和建立它的覆盖结构的。因此，通常覆盖技术主要用于系统内部程序的主存管理上

   覆盖技术的主要特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，在一定程度上解决了小主存运行大进程的矛盾，在逻辑上扩充了主存。但当同时运行程序的代码量大于主存时仍不能运行

2. **交换（Swapping）**

   交换技术被广泛运用于早期的小型分时系统的存储器管理中。一方面解决主存容量不够大的问题；另一方面使各分时用户能保证合理的响应时间。所谓交换，就是系统根据需要把主存中某个（或某些）暂时不运行的进程的部分或全部信息移到外存，而把外存中的某个（或某些）进程移到相应的主存区，并使其投入运行

   交换通常在以下情况发生：

   - 进程用完分配的时间片或等待 I/O 时
   - 进程要求扩充其占用的存储区而得不到满足时

   交换技术的关键是设法减少每次交换的信息量。为此，常将进程的副本保留在外存，每次换出时，仅换出那些修改过的信息即可

   交换技术也是利用外存来逻辑地扩充主存。它的特点是打破了一个程序一旦进入主存便一直运行到结束的限制。其缺点也是进程的大小受实际主存容量的限制

### 页式存储器管理

页式存储器管理允许一个进程占用不连续的存储区域，从而克服了碎片

1. **页式管理的实现原理**

   页式管理的主要特征是把主存分成大小相等的若干块，又叫做页框。块的大小可以根据实际情况定，一般为1024或4096字节等2的整次幂。于此对应，运行进程的地址空间也划分成与主存块同样大小的页或虚页

   为实现分页，硬件把 CPU 产生的地址分解为页号和页内地址两部分。其中页号与页内地址各占多少位，同页的大小和主存最大容量有关

   在进行存储分配时，总是以块为单位进行的，而且允许分配的主存块不连续，从而克服了主存的碎片问题

   为实现动态地址变换，系统为进入主存的程序建立一个页表，记录该进程的逻辑页与主存块的映射关系

2. **页式动态地址变换**:book:

3. **快表和联想存储器**:book:

   执行一次访内操作至少要访问主存两次。一次是访页表，一次是实现指定操作。这样就把程序的执行速度降低了1倍。为了提高存取速度，通常设置一个专用的硬件高速缓冲寄存器组，又叫联想存储器。在联想存储器中，包含了最近用过的大多数的页表项。把存放在高速缓冲寄存器中的页表叫快表，它的存储单元能被同时读取

   硬件地址转换机构在进行地址转换时，同时开始两个变换过程。一个是利用主存页表进行的正常变换过程，另一个是利用快表进行的快速变换过程。一旦快表中找到向匹配的页号时，将立即停止正常的访问主存页表过程

4. **页式管理的主存分配与保护**

   - 页式主存分配：

     为了实现分页管理，系统必须建立和管理三种表

     - 页表：每个进程一个，放在主存的专门区域，用来将进程的虚页转换成主存的物理块
     - 进程控制块：在进程控制块中增加这样的信息：该进程的页表在主存的始址和页表长度
     - 存储空间使用情况表：为了记录存储空间的使用情况，通常使用存储分块表和位示图:book:。主存分块的大小是一个很重要的设计问题。分块越小，位示图越大；分块越大，位示图越小。但块越大，可能会产生页内碎片，应折中考虑。查找位示图是费时的操作

   - 页式管理的存储器共享与保护：

     页式存储器管理中实现存储器的共享是比较容易的，只需要在不同进程的页表中指向相同的物理页框就可以了

     为了实现页式管理的存储器保护、需要硬件提供每个页框相关的读写或只读或只执行等保护标识位。通过页表找到对应的页表项，先检查是否允许执行指定操作，若不允许，故障终止进程的执行；若允许，才进行地址转换

### 段式存储器管理

之前的各种存储器管理技术中，用户的逻辑地址空间已被静态地链接成一个一维的地址空间。这与现代的编程方式不太符合。一个进程通常由若干个程序段和数据段组成。用户进程共享现有的一些程序段和数据段是现代操作系统必须要解决的问题，段式管理正是为了适应这种需要而产生的

1. **段式管理的实现原理**

   段式管理要求每个进程的地址空间按照程序自身的逻辑关系划分成若干段，每个段都有自己的名字和长度。这样的地址空间是一个二维的地址空间。为了方便管理，系统为每一个段名都规定了一个内部段号:book:

   段式存储器分配是以段为单位进行的，为进程的每一个分段分配一个连续的主存区，各段之间可以不连续。系统在主存设置段表来记录一个进程各个分段分配的主存的始址、本段的长度和允许的访问方法。并将该进程的段表在主存的始址和长度记录在进程控制块中

2. **段式动态地址变换**:book:

3. **段式管理的存储器保护和共享**

   - 段式管理的存储器保护：仅当访问的操作方式、段号和段内地址都合法时，才能执行指定的操作
   - 段的共享：容易实现信息的共享。通过使各进程的段表项指向共享段在主存的物理地址来实现

4. **段的存储器分配**

   段的存储器分配类似于可变式分区，其分配策略同样可采用首次适应、最佳适应或最坏适应算法。所不同的是，可变式分区管理是以进程为单位分配一个连续的分区，而段式管理是以段为单位进行分配的。段式与分区管理类似，其碎片问题同样也是不可避免的

5. **段式与页式管理的比较**

   - 段是信息的逻辑单位，它是由用户划分的，因此段对用户是可见的；页是信息的物理单位，是为了方便管理由硬件划分的，对用户是透明的
   - 页的大小固定不变，由系统决定。段的大小是不固定的，由其完成的功能决定
   - 段向用户提供的是二维地址空间，页向用户提供的是一维地址空间，其页号和页内地址是机器硬件的功能
   - 段是信息的逻辑单位，允许动态扩充，便于存储保护和信息的共享；页是信息的物理单位，其大小是固定不变的，页的保护和共享受到限制
   - 段式管理与分区管理一样可能产生主存碎片，而页式管理则较好地消除了碎片
   - 段式管理便于实现动态链接，而页式管理只能进行静态链接
   - 段式与页式一样，为了实现管理，需要系统设置更多的表格，系统开销较大

### 虚拟存储器管理

之前的存储器管理技术的特点是要求运行进程的地址空间必须全部装入主存。当进程的地址空间大于主存可用空间时，该进程就无法运行。这种存储器管理技术叫实存管理技术

与实存管理技术相对应的是虚拟存储器管理技术

1. **虚拟存储器的概念**

   虚拟存储器是为满足应用对存储器容量的巨大需求而为用户构造的一个非常大的地址空间。它允许进程的地址空间不必全部进入主存就可以执行，从而使用户在编程时无须担心存储器不足。

   当系统提供给用户程序的有效寻址范围与主存大小无关时，称该机器提供了虚拟存储器管理技术

2. **程序访问的局部性原理**

   - 时间局部性：程序中往往含有许多循环，一旦某部分的指令被执行或某部分数据被访问后，则在不久之后会重复执行或访问这一部分
   - 空间局部性：程序中有些部分是彼此互斥的（例如分支）。程序一次运行时，只有其中满足条件的那部分代码运行，不满足条件的代码不被执行。即使顺序执行的程序，也会随着程序的执行，其地址域在相对短的时间段内，变化不大

   进程执行时没有必要把全部信息同时装入主存储器中，只要装入部分信息，就可以运行。在运行过程中用到哪部分信息时再由系统自动装入。这种技术使得进程之间共享主存的信息比覆盖更容易实现，而大大提高了主存的利用效率

3. **支持虚拟存储器的物质基础**

   通常为了向用户提供巨大的地址空间，系统采用了多级存储结构，最流行的是由主存和外存的一部分组成的二级存储器，以及相应的地址转换机构。这样，使用户程序一方面可以获得具有很大容量的外存空间，另一方面仍保持高速主存的存取速度

### 页式虚拟存储器管理

1. **实现原理**

   虚拟页式存储器管理又叫请求页式管理。它是页式管理基础上增加交换技术而实现的。请求页式管理与页式管理的主要区别是，将进程信息的副本存放在磁盘等快速辅助存储器中，并为其建立一个外页表，指出各页对应的辅存地址。当进程被调度运行时，只将进程当前需要的较少页装入主存，在执行过程中，访问不在主存页时，再将其换入

   主要涉及三方面的内容：

   - 取页：将进程的哪个或哪些页交换进主存
   - 置页：取来的页放在主存的什么位置
   - 置换：当主存无空闲空间时，将哪个或哪些页换出去

   需要在页面增加一个有效位和修改位：

   - 有效位：指示某页是否在主存。若在则为1；不在则为0
   - 修改位：指示某页被调入主存后是否被修改过。若为1则被修改过，要将淘汰的页写回磁盘，以保证信息的一致性；若为0则没有修改过，新调页直接覆盖它即可

   存储不在主存的页的磁盘空间通常叫做交换区

   由于从磁盘交换区向主存调入一页需要的时间较长，故在调页过程中应将请求调页的进程设置为阻塞态，直到该页换入主存再将其唤醒

2. **页面淘汰算法**

   选择哪个页淘汰，非常重要，如果选择不当，就会出现这样的现象：刚被淘汰的页面马上又要用，因而又要把它调入，调入不久再被淘汰，淘汰不久再次装入，如此反复，使整个系统处于频繁的调入调出状态，大大降低系统的处理效率，这种现象叫抖动

   假定一个进程分配的主存块数固定不变，且采用局部淘汰，即只考虑本进程内部实施淘汰。进程开始时，主存没有装入一页信息:book:

   - 最佳置换算法（Optimal, OPT）：

     选择以后不再访问的页或经很长时间之后才可能访问的页进行淘汰

     该算法是无法实现的，因为产生缺页时，操作系统不知道每个页面的下次访问时间。通常使用这种算法去衡量所采用算法的性能好坏

   - 先进先出淘汰算法（FIFO）：

     当淘汰一页时，选择在主存驻留时间最长的那一页进行淘汰

     操作系统维护一张当前页表（队列），表的长度为当前运行进程分配的主存块数:book:

     这种算法实现简单，但效率不高。因为在主存时间最长的页未必是最长时间以后再被访问的页。这样，有可能出现抖动。

     另外，Belady 发现采用 FIFO 算法时，为进程分配的主存块多时，有时产生的缺页中断次数反而比分配主存块少时增多。称之为 Belady 异常

   - 最近最少使用的页面淘汰算法（Least Recently Used, LRU）：:book:

     这种算法是淘汰那些在最近一段时间里最少使用的一页。它是根据程序执行时所具有的局部性原理考虑的。称进程在一段时间内集中访问的这个固定子集为该进程的工作集

     实验证明，这是一种较好的算法，但系统开销较大

     它绝不会出现 Belady 异常。把具有这种性质的算法叫做栈式算法

   - 时钟页面置换算法：:book:

     又叫做第二次机会算法，也是近似 LRU 算法

   - 工作集模型法：

     设法记录每个进程的工作集，并确保在进程运行前将其工作集调入主存，以大大减少进程的缺页率，甚至在一段时间内不产生缺页中断，从而大大提高了系统的运行效率

3. **页面管理设计中应考虑的问题**

   - 交换区的管理：

     交换区是操作系统利用磁盘的一部分空间扩充主存的主要方法

     它可以或者用来保存进程运行的整个映像，或简单地存储分页系统可能被淘汰的页

     交换空间的设置有两种方法：

     - 可以从文件系统中分割一部分空间作为一个大文件使用
     - 使用一个磁盘分区或独立的磁盘

   - 页面的尺寸：

     页是硬件级保护的最小单位

     - 一个进程通常包括代码段、数据段和堆栈段，这些段不可能正好填满所分配的各页。平均来讲，最后一页的半页是空的，也即每个段平均浪费半页，这部分叫做内部碎片。为了减少内部碎片，应设法减小页尺寸

     - 页尺寸越大，将无用的程序装入主存越多，从而使主存浪费更大

     - 页面越大，页面传输次数越少，页面传输时间越短；页面尺寸越小，进程页表越长

     - 由于一个页必须具有一种保护方式，如果在一个大页中既包含只读代码也包含可读写代码，该页只能被标为可读写。可能导致只读代码被修改。在这方面，小页的好处是明显的

     为了更加有效地工作，一个系统往往允许同时存在几个不同的页面尺寸。x86系统结构在引入了扩展分页机制后，允许系统同时有4KB和4MB大小的页面存在

   - 页的共享：

     避免在主存中同时有多个相同页的副本

     不是所有页都可共享，通常只有只读页，如程序文本，可以被共享，而可读写的数据页不可共享

     将被共享页锁在主存，并在页表中增加引用计数项，仅当其引用计数为0时，才允许调出或释放共享页占用的空间

   - 多级页表结构：

     采用多级页表结构，使页表不再占用连续的主存空间，且页表在使用时才被装入，从而大大节约了主存空间

     划分的级数越多，执行一个访内操作花费的时间就越长。为了减少查找多级页表时间，可以采用散列算法构造页表或采用转置页表

   - 写时复制技术：

     当两个进程要读写相同内容的主存时，系统就给该主存区赋予写时复制的页面保护。若没有进程向共享主存区写时，两个进程就共享它。一旦一个进程要向共享页写时，系统就把此物理页复制到主存的另一个页框中，并更新该进程的页表指向此复制的页框，且设置该页为可读写。而这个被复制的页面对其他进程不可见。其他进程继续共享未经改动的页

### 段式虚拟存储器管理

1. **实现原理**

   又叫请求段式管理。把进程的所有段的副本存放在磁盘一类的辅助存储器中，当进程被调度运行时，首先把当前需要的段装入主存，在执行过程中访问不在主存的段时，再将其装入

   需要对段表进行修改:book:

   段的地址转换过程:book:

2. **段的动态链接和装入**

   链接是指多个目标模块在执行时的地址空间分配和相互引用。单一连续区、分区、页式和段式的实存管理下运行的程序通常采用静态链接的方法实现。它的最大好处是简单，但造成时间和空间上的巨大浪费

   为减少不必要的时间和空间上的浪费，段式虚存管理采用段的动态链接，是在程序装入或运行时进行的链接。通常被链接的共享代码称为动态链接库（Dynamic-Link Library, DLL）或共享库（Shared Library）

   间接编址字和链接中断位:book:

3. **段的共享**

   段式虚存管理利用段的动态链接很容易实现段的共享

   为便于多进程共享主存中的公用子程序，可在主存中设置一个共享段段表，其内容可包括共享段名、在主存的始址、段长、调用该段的进程数及进程名

### 段页式虚拟存储器管理

段与页有着各自的优缺点，将页式管理和段式管理结合起来，就可以获得页式管理高的主存利用率和段式管理便于信息保护和共享的优点

基本思想是程序的逻辑结构按段划分，每段再按页进行划分

1. **x86系统的分段**:book:
2. **x86系统的分页**:book:

