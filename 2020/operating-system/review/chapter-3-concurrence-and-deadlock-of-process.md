# 第3章 - 进程之间的并发控制和死锁

### 进程并发的特点

1. **对资源的共享引起的互斥关系**

   这是一种间接制约关系，即互斥关系

2. **协作完成同一个任务引起的同步关系**

   进程可能要在某些同步点上等待协作者发信息后才能继续运行。这种关系叫做直接制约关系，又叫同步关系

3. **进程之间的前序关系**

### 进程之间的互斥

1. **临界资源和临界区**

   所谓临界资源，就是一次仅允许一个进程使用的系统中的一些共享资源。临界区就是并发进程对临界资源必须互斥操作的那段程序，一个变量可以有几个相关的临界区。

   系统为并发进程制定了进入临界区需要遵循的原则：

   - 不能同时有两个进程在它们的临界区内执行：互斥使用
   - 等待进入临界区的进程，应释放处理机后阻塞等待：让权等待
   - 在临界区之外运行的进程不可以阻止其他的进程进入临界区：有空让进
   - 不应该使要进入临界区的进程无限期地等待在临界区之外：有限等待

2. **解决进程之间互斥的硬件实现方法**

   - 关中断：当一个进程在临界区内执行时，关闭所有的中断。方法简单，但系统要付出较高的代价，限制了处理机交叉执行程序的能力，且在多处理机的情况下会失效
   - 使用测试和设置硬件指令：该机器指令可以原子性地读取一个变量的值，然后再设置新的值。Test & Set。会造成忙等待。:book:

### 进程之间的同步

进程的同步是指一组共行进程，各自以独立的、不可预知的速度向前推进，在前进过程中彼此之间需要相互协调步伐，才能正确地完成同一项任务

### 进程的低级通信

低级通信主要用于进程之间的同步和互斥等控制信息的传递。包括信号量和管程

- 优点是速度快
- 缺点有：
  - 传送信息量小且效率低，每次通信只能传输一个单位的信息
  - P、V 操作的使用增加了程序的复杂性，操作使用不当容易导致死锁
  - 在程序非正常撤离时，查找只做 P 操作而未做 V 操作的进程是很困难的

### 信号量和 P、V 操作

P 操作相当于申请资源，V 操作相当于释放资源。有的资料用 wait() 和 signal() 来代替

n 个进程并发执行时，信号量的可能取值范围为 +1～-(n-1)。

### 利用信号量解决计算机中的经典问题

1. **生产者消费者问题**:book:

   无论是生产者还是消费者，P 操作的顺序是重要的。如果将生产者进程中的两个 P 操作的次序交换，当缓冲区满时，生产者欲向缓冲区放产品时，将在 P(empty) 上等待，但它已经获得了使用缓冲区的权力。若此后，消费者欲取产品时，由于申请使用缓冲区不成功，它将在 P(mutex) 上等待。从而导致生产者等待消费者取走产品，而消费者却在等待生产者释放缓冲区，这种相互等待就会造成系统发生死锁现象

2. **读者与写者问题**:book:

   - 读者优先
   - 写者优先
   - 公平竞争

3. **理发师问题**:notebook:

4. **哲学家就餐问题**:notebook:

### 管程

1. **管程的定义**

   管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。管程与 C++ 中的类相似，它隐含了代表资源的数据的内部表示，向外部提供的只有为各方法规定的操作特性。管程保证任何时候最多只有一个进程执行管程内的代码。并发进程在请求和释放共享资源时调用管程，从而提供了互斥机制，保证管程数据的一致性

   管程由三部分组成：

   - 局部于该管程的共享数据说明
   - 对共享数据执行的一组操作过程说明
   - 局部于该管程的共享数据置初值的语句

2. **利用管程解决进程之间的同步与互斥**:book:

   - 用管程解决临界区资源的互斥使用
   - 用管程解决生产者消费者问题

### 进程的高级通信

高级通信是指进程采用系统提供的多种通信方式，如消息缓冲、信箱、管道和共享主存区等，实现的通信。通信进程通过发送消息和接收消息的办法，把通信内容直接或间接地传给对方，一次通信可交换若干个信息。

对于发送进程，有两种可能的通信方式：

- 发送完消息后，不等待消息被接收就继续前进
- 发送完消息后，阻塞等待，直到收到接收者的回答消息才继续前进

对于接收进程，有两种可能的通信方式：

- 若有消息，则接收这个消息后继续前进
- 若无消息，它可能或者等待消息的到来，或者放弃接收而继续前进

由此可见，接收者和发送者进程在采用消息通信方式时，有三种组合：

> 单向通信

- 非阻塞发送，阻塞接收
- 非阻塞发送，非阻塞接收

> 双向通信

- 阻塞发送，阻塞接收

### 消息缓冲通信

1. **消息缓冲实现机制**

   消息缓冲通信有两种实现方法：

   - 系统负责设立一个消息缓冲池，其中每个缓冲区可以存放一个消息，每当进程欲发送消息时，向系统申请一个缓冲区，将消息存入缓冲区，然后把该缓冲区链接到接收进程的消息队列上。消息队列通常放在接收进程的进程控制块中
   - 每个进程设立一个信箱，每个信箱可容纳多封信件。此信箱中的信件是操作系统执行发送原语将信件投入指定信箱，由接收者自行接收信件并进行处理

2. **消息通信原语**

   - 发送消息原语：

     `send(接收者, 被发送消息始址)`

     每当进程欲发送消息时，在自己的地址空间形成以消息发送区，将消息写入其中。之后调用发送原语发送消息。该原语的作用是，首先在系统缓冲区中申请一个消息缓冲区，将消息从发送去传入其中，并将发送者进程的名字、消息始址及消息的长度等填入缓冲区中，之后将该消息缓冲区挂到接收进程的消息链上

   - 接收消息原语：

     `receive(发送者, 接收区始址)`

     接收原语的主要工作是检查消息链上是否有消息，若无，则根据采用的通信方式决定其进一步的行动；若有，将消息接收到接收区。若之后消息缓冲区已经变空，则释放该缓冲区

   - 通信流程:book:

3. **信箱通信原语**

   信箱是操作系统提供给进程的间接通信方式。发送进程发消息时不指定接收进程的名字，而是指定一个中间媒介——信箱。一个信箱可以容纳若干个信件。通过调用发送原语将信件投入指定信箱，由接收者自行接收信件并进行处理

   - 发送消息原语：

     `send(信箱, 信件)`

     当有进程发送信件时，若指定信箱未满，则将信件送入信箱的指定位置，否则发送失败

   - 接收消息原语：

     `receive(信箱, 信件)`

     当有进程接收信件时，若指定信箱中有信件，则取走一封，并检查是否有发送者在等待发送，若有等待的发送者，则唤醒之

### 其他通信机制

1. **管道通信**

   是指用于连接一个写进程和一个读进程的一个共享文件。该文件按照先进先出方法实现它们之间的通信。是通过操作系统管理的核心缓冲区（通常几 KB）来实现的单项通信方式

2. **共享存储区**

   诸进程为了相互交换大量数据，在主存中划出了一块共享存储区，并将该共享存储区连接到它们各自的地址空间的某一部分。诸进程通过读或写共享主存区中的数据来实现通信。这是进程通信中最快捷的一种方式，但要注意协调它们之间的速度，以保证共享数据的一致性

### 死锁的定义和产生死锁的必要条件

1. **资源的特性**

   计算机系统中的资源分为两类，可抢占和不可抢占：

   - 可抢占资源：当这类资源从占用进程剥夺走时，对进程不产生什么破坏性的影响。主存和 CPU 就属于这一类。对于可抢占资源，通过资源的重新分配，很容易解决存在的死锁情况。也就是说不会因为竞争这类资源使系统进入死锁状态
   - 不可抢占资源，又称临界资源：当这类资源从占用进程剥夺走时，可能引起进程计算失败。如慢速的设备、共享变量和队列等

   通常情况下，死锁设计的是不可抢占资源，一般情况下，一个进程必须按照三个步骤使用系统资源（CPU 除外）：

   - 请求资源：若请求不能立即满足，则申请者等待
   - 使用资源：获得资源后，可使用它
   - 释放资源：使用完毕后，将资源归还系统

2. **死锁的定义**

   一组进程是死锁的，是指这一组中的每个进程都正在等待这一组中的其他进程所占有的资源时可能引起的一种错误现象

3. **死锁产生的必要条件**

   - 互斥条件：每个资源是不可共享的，它或者已经分配给一个进程，或者空闲
   - 保持和等待条件：进程因请求资源而被阻塞等待时，对已经分配给它的资源保持不放
   - 不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程强行剥夺，只能由获得资源的进程自己释放
   - 循环等待条件：存在一个进程循环链，链中有两个或多个进程，每个进程正在等待链中的下一个成员保持的资源

4. **死锁产生的原因**

   - 系统资源配置不足，因而引起进程竞争资源
   - 系统的各并发进程请求资源的随机性，这包括所请求的资源类别和数量
   - 各进程在系统中异步向前推进，造成进程推进顺序的非法性

### 解决死锁的方法

进程-资源分配的有向图:book:

1. **鸵鸟算法**

   置之不理或忽略，假装毫无问题

2. **死锁的预防**

   - 破坏互斥条件：资源的互斥使用条件是由资源本身的性质决定的，因此不能破坏。使用 spooling 技术，可以借助于共享设备的一部分空间将一台独享设备改造成多台设备，以满足多个进程的共享使用。但实际中，不是所有设备都能采用 spooling 技术，即使能采用，由于多个进程竞争磁盘空间，磁盘空间的不足，也依旧可能产生死锁
   - 破坏保持和等待条件：进程在开始前，必须获得其所需的全部资源。若系统不能满足，则该进程等待。这就是资源的静态分配。这种分配方式使资源利用率很低。而且，许多进程在开始运行前，不能精确提出所用资源数量
   - 破坏非剥夺条件：当一个进程已经占有一个资源，而其他资源不能满足时，则在进入阻塞态前强行释放已占有的资源。以后再运行时，再重新申请。这也是不可行的，因为保护进程放弃资源时的现场以及之后现场的恢复，系统要付出很高的代价
   - 破坏循环等待条件：该方法就是采用资源的有序分配法。将系统的全部资源按类进行全局编号排序，所有进程对资源的请求必须严格按序号递增顺序进行。采用这种限制后，进程-资源图就不会形成环路，也就不会死锁

3. **死锁的避免**

   - 进程-资源轨迹:book:
   - 同一类资源的银行家算法：:book:
     - 当一个进程提出一个资源请求时，假定分配给它，并调用检查系统状态安全性的算法，如果系统是安全的，则对申请者的假分配变为实际的分配。否则，推迟它的请求，让其阻塞等待
     - 检查系统安全性的算法：根据系统剩余的资源情况，银行家进行检查，看满足请求者的要求后，是否仍使系统中的所有进程都能正常完成（即能找到一个进程完成序列），若能，则系统是安全的，反之是不安全的
   - 多类资源的银行家算法:book:

   > 银行家算法是在系统运行期间实施的，需要花费大量时间判断系统状态的安全性，而且算法本身比较保守

4. **死锁的检测和恢复**

   死锁的检测和恢复技术是指系统不试图防止死锁发生，代之的是让它发生。当它发生时，再设法检测，然后采取措施恢复之

   - 死锁的检测：就是对系统中的进程-资源图进行检查，如果进程-资源图包含了一个或多个循环，就存在死锁，且环路中的任何一个进程都是死锁进程；如果没有环路存在，则该系统没有死锁（具体算法 DFS）

   - 死锁的恢复：

     当检测到死锁的存在时，有几种死锁恢复的方法：

     - 故障终止一些进程：

       - 故障终止所有进程：这种方法简单，被终止进程原先的计算作废，以后重新开始计算
       - 一次故障终止一个进程，直到死锁解除为止：这将会使系统开销很大，因为每次都要探测死锁是否解除

       选择撤销进程时，尽可能对系统影响较小。通常应遵循一些原则：

       - 目前刚启动的进程
       - 目前为止产生的输出最少
       - 撤销时，系统耗费的处理机时间较少
       - 目前为止分配的资源总量最少
       - 进程的优先级最低

     - 资源剥夺：为了使死锁恢复，暂时从当前占有者夺走一部分资源给另一些进程，直到死锁恢复

       - 从一个进程取走资源给另一进程使用：然而，从一个进程取走资源之后再返回给它的能力是与资源本身的特性密切相关的。采用剥夺方法使系统从死锁中恢复常常使困难的，或不可能的。
       - 回滚一些进程

     死锁的检测和恢复技术虽然有效，但消耗系统的时间太多，实际也很少使用，往往采用简单的人工干预，来解除死锁

