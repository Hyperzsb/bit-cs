# 编译原理复习提纲

## 编译引论



## 形式语言与自动机理论基础



## 词法分析



## 语法分析——自上而下分析



## 语法分析——自下而上分析



## 语义分析与中间代码生成



## 运行环境

### 教材内容

- 过程、活动和生存期：

  - 过程的每一次运行称为一次活动。活动是一个动态的概念，它有有限的生存期
  - 活动的生存期是指从进入活动的第一条指令执行到离开此活动前的最后一条指令执行的这段时间，其中包括调用其它过程时其它活动的生存期

- 绑定：运行时为名字 X 分配存储空间 S，这一过程称为绑定

- 声明时关心的是声明的作用域,，即当一个名字被引用时，在不同的作用域中与该名字的不同声明结合

- 绑定时关心的是绑定的生存期，即当一个名字在 运行时被实际分配的存储单元，名字与存储单元结合 的这段时间被称为绑定的生存期，显然此生存期应该 和名字的生存期一致

- 静态与动态：

  |     静态     |     动态     |
  | :----------: | :----------: |
  |  过程的定义  |  过程的活动  |
  |  名字的声明  |  名字的绑定  |
  | 声明的作用域 | 绑定的生存期 |
  |    符号表    |   活动记录   |

- 运行环境：指目标计算机的寄存器及存储器结构，用来管理存储器并保存执行过程所需的信息

- 变量与值的两步映射：

  - 变量名字的映射：名字通过环境（绑定）到存储位置，存储位置通过状态（赋值）到值
  - 常量名字的映射：名字通过环境（绑定）直接到右值
  - 赋值改变状态，但不改变环境

- 存储分配策略：

  - 存储分配的原则：尽可能对数据对象进行静态分配
  - 静态分配策略：在编译时能够确定目标程序运行时所需的全部数据空间的大小，即在编译时就可以将程序中的名字关联到存储单元，确定其存储位置
    - 限制：
      - 数据对象的长度和它在内存中的位置的限制必须在编译时知道
      - 不允许递归过程，因为一个过程的所有活动使用同样的局部名字结合
      - 数据结构不能动态建立，因为没有运行时的存储分配机制
  - 动态分配策略：在编译时不能确定目标程序运行时所需的全部数据空间的大小，而是在目标程序运行时动态确定的
    - 栈式动态存储分配
    - 堆式存储动态分配

- 存储区保存的对象：

  - 生成的目标代码
  - 目标代码运行时的数据空间
  - 记录过程活动的控制栈

- 活动记录（AR）：一块连续的存储区，被用来存放过程或函数的一次调用执行所需要的信息

  - 基本内容：
    - 自变量实参空间
    - 局部数据空间
    - 局部临时变量空间
    - 保存的机器状态信息
    - 返回地址
    - 存取链（SL）：指向定义该过程的直接外层过程运行时最新活动记录的基地址
    - 控制链（DL）：指向调用该过程前正在运行过程的活动记录基地址

- 嵌套过程语言的栈式分配：

  - 语言层面：一个过程可以引用包围它的任一外层过程所定义的标识符（如变量，数组或过程等）
  - 实现层面：一个过程可以引用它的任一外层过程的最新活动记录中的某些数据
  - 关键技术：
    - 解决对非局部量的引用：设法跟踪每个外层过程的最新活动记录 AR 的位置
    - 跟踪方法：用静态链；用 Display 表
    - Display 表：嵌套层次现实表；当前激活过程的层次为 K，它的 Display 表含有 K+1 个单元，自第 K+1、 K、...、0 个单元依次存放着现行层，直接外层...直至最外层的每一过程的最新活动记录的基地址

- 堆分配策略：

  - 可任意分配和撤消数据；对程序设计语言没有限制

### 扩展内容

## 代码优化

- 代码优化概述：

  - 代码优化的概念：
    - 代码的质量包括目标程序所占的存储空间的大小和运行时间的长短
    - 代码优化应遵循等价、有效和合算的原则
  - 优化技术分类：
    - 从优化涉及的源程序范围角度：
      - 局部优化
      - 循环优化
      - 全局优化
    - 从优化相对于编译逻辑功能实现的不同阶段及目标机的关系角度：
      - 中间代码级优化（与机器无关的优化）
      - 目标代码级优化（与机器有关的优化）
    - 从优化的具体实现角度：
      - 常量合并与传播
      - 公共子表达式删除
      - 无用赋值的删除
      - 死代码删除
      - 无用转移语句的删除
      - 循环不变量或不变代码外提
      - 函数内嵌
      - 循环转换：
        - 简单循环内的运算强度削弱：
          - 是将原来处于循环体内多次乘法运算用强度较低的加法运算代替
          - 这种优化的效果随着循环体执行次数的增加而提升
        - 动态循环内的运算强度削弱
        - 多步循环内的循环归纳变量外提：
          - 在每次循环时，如果循环迭代增量的改变多于一次，则称这种类型的循环为多步循环
          - 循环增量在循环体内改变多次，且其值的改变是线性的，具有这种性质的循环控制变量称为循环归纳变量
        - 复合变量循环的转换：
          - 将具有一个以上的循环控制变量或迭代增量，而且这些量之间存在某种线性关系，这样的循环称为复合变量循环
      - 其他：
        - 指令调度
  - 优化编译程序的组织：
    - 通常代码优化阶段由控制流分析、数据流分析和代码变换三部分组成

- 局部优化：

  - 基本块的定义与划分
  - 程序的控制流图
  - 基本块的 DAG 表示及应用
    - DAG 定义与基本块的 DAG 表示
    - DAG 构造与局部优化：
      - DAG 可以完成的局部优化包括：
        - 合并已知量
        - 删除公共子表达式
        - 删除无用赋值

- 控制流分析与循环查找：

  - 循环的查找：
    - 结点序列是强连通的：这是指该序列中的任意两个结点之间，一定存在一条通路，且该通路上的所有结点都属于该结点序列。特别是如果该序列只包含一个结点，则必有一条有向边从该结点引到其自身
    - 结点序列中有一个且只有一个是入口结点。其入口结点一定具有，从序列外某个结点有一条有向边引到它或它是程序控制流图首结点
  - 定义：必经结点
  - 定义：必经结点集
  - 定义：回边
  - 利用回边可以直接求出流图中的循环

- 数据流分析：

  - 程序中的点与通路

  - 到达-定值数据流方程及其方程求解

    - 定值到达的含义：所谓变量 A 在某点 d 的定值到达另一点 u，是指流图中从 d 有一通路到达 u 且该通路上没有对变量 A 的再定值
    - 定义性出现（定值点）和引用性出现（引用点）
    - IN(B)、OUT(B)、GEN(B) 和 KILL(B)

  - 引用-定值链（ud 链）

    - 假设在程序中某点 P 引用了变量 A 的值，则把能到达 P 的 A 的定值点的全体，称为 A 在引用点 P 的引用-定值链（即 ud 链）

    - 计算规则：

      - 如果在基本块 B 中，变量 A 的引用点 P 之前有 A 的定值点 d，并且 A 在点 d 的定值到达 P，那么，A 在点 P 的 ud 链即为 {d}

      - 如果在基本块 B 中，变量 A 的引用点之没有变量 A 的定值点，那么，IN(B) 中 A 的所有定值点均到达 P，它们均是变量 A 在点 P 的 ud 链

  - 活跃变量与数据流方程：

    - 活跃和死亡
    - INL(B)、OUTL(B)、DEFL(B) 和 USEL(B)

  - 定值-引用链（du）链与 du 链数据流方程

    - 假设在程序中某点 P 对一个变量 A 定值，则把该定值能到达的 A 的引用点的全体，称为 A 在引用点 P 的定值-引用链（即 du 链）

  - 可用表达式数据流方程

- 循环优化：

  - 代码外提
  - 强度削弱
  - 变换循环控制变量（删除归纳变量）：
    - 删除归纳变量应在强度削弱之后进行，因为在强度削弱后，可能会产生新的归纳变量

- 优化的基本流程：一般在进行程序的控制流分析和数据流分析之后开始优化。先进性循环优化；然后可进行某些全局优化，主要是合并已知量与常数的复写传播；接着进行基本块优化；最后再进行全局性的复写传播，把循环优化及删除全局和局部公共子表达式后新产生的不必要的复写删除；复写传播后可能会产生新的公共子表达式，所以某些优化可能要重新进行

## 代码生成

### 目标机器和调用协定



### 一个简单的代码生成器



### 指令选择

- 根据指令匹配项的不同有多种选择方案；各种方案具有不同的生成结果
- 若能完全覆盖

### 寄存器分配

- 存储层次
- 基本分配方法：
  - 不分配：对于每个四元式，每次操作前先 Load，操作后再 Store
  - 固定分配：
    - 给前 m 个局部变量分配 m 个寄存器
    - 给前 n 个栈空间分配 n 个寄存器
    - 其余的变量使用不分配的方法（通常会保留两个寄存器用于该目的）
  - 基于基本块的分配：
    - 是对于不分配的扩展
    - 对于每个基本块，每次进入时先 Load，退出时再 Store
- 线性扫描：
  - 当两个变量不是同时活跃的，可以使用同一个寄存器
  - 基本思路和方法 :book:
    - 寄存器个数大于活跃变量个数
    - 寄存器个数小于活跃变量个数：放回去再分配
- 图着色：
  - 画出寄存器干涉图（RIG）：若两个变量有冲突（即某一时刻同时为活跃变量），则连接两个变量对应的两个点
  - 基本思路和方法 :book:
    - 从图中依次删除节点，判断是否可以使用指定数量的颜色来着色
      - 对于超出限度的节点（冲突最多的点、定义和使用最少的、尽量避免选择内层循环中的点），在每次引用前进行 Load，在每次定值后进行 Store；原始的活跃变量集会发生改变

## 算法

### 词法分析

- 非确定有限自动机的确定化算法（子集法）：:heavy_check_mark:
  - 求集合 $I$ 的 $\varepsilon$ 闭包 :heavy_check_mark:
  - 求从集合 $I$ 的 $\varepsilon$ 闭包出发，经过一条 $a$ 弧而到达的状态集的 $\varepsilon$ 闭包 :heavy_check_mark:
- 消除确定有限自动机中的无关状态算法 :heavy_check_mark:
- 消除确定有限自动机的等价状态算法（划分法） :heavy_check_mark:
- 正规式与有限自动机的等价转换算法
  - 由正规式构造非确定有限自动机
  - 由非确定有限自动机构造正规式

### 语法分析

- 自上而下分析：

  - 消除文法左递归：
    - 消除直接左递归 :heavy_check_mark:
    - 消除间接左递归 :heavy_check_mark:

  - 构造 FIRST 集 :heavy_check_mark:
  - 构造 FOLLOW 集 :heavy_check_mark:
  - LL(1) 分析算法 :heavy_check_mark:
  - LL(1) 分析表的构造 :heavy_check_mark:
  - 判断是否为 LL(1) 文法 :heavy_check_mark:

- 自下而上分析：
  - LR 分析算法 :heavy_check_mark:
  - 构造文法的 LR(0) 项目集规范族：:heavy_check_mark:
    - 项目集 $I$ 的闭包算法 :heavy_check_mark:
    - GO 函数算法 :heavy_check_mark:
  - LR(0) 分析表的构造： :heavy_check_mark:
    - 基于识别可规约前缀的 DFA 进行构造
    - 基于 LR(0) 项目集规范族 C 和 GO 函数进行构造 :heavy_check_mark:
  - 判断是否为 LR(0) 文法 :heavy_check_mark:
  - SLR(1) 分析表的构造 :heavy_check_mark:
  - 判断是否为 SLR(1) 文法 :heavy_check_mark:
  - 构造 LR(1) 项目集规范族：:heavy_check_mark:
    - 项目集 $I$ 的闭包算法 :heavy_check_mark:
    - GO 函数算法 :heavy_check_mark:
  - LR(1) 分析表的构造
  - 判断是否为 LR(1) 文法 :heavy_check_mark:
  - LALR(1) 分析表的构造
  - 判断是否为 LALR(1) 文法 :heavy_check_mark:

### 代码优化

- 基本块的 DAG 的构造算法
- 求流图所有结点的必经结点
- 计算变量的定值点信息
- 计算活跃变量信息
- 查找循环的不变运算
- 代码外提算法

### 寄存器分配

- 线性扫描法
- 图着色法

## 题目

- 设正规式 r 对应的正规集合中有 m 个元素、正规式 s 对应的正规集合中有 n 个元素，则正规式 rs 对应的正规集合中有 mn 个元素。（是错的）
- 扫描器采用对半互补技术的主要原因：便于进行超长搜索和回退字符
- Yacc 采用移进规约分析方法实现
- 控制流检查属于静态语义检查的内容