# 软件工程复习提纲

### 软件工程概述

1. **软件工程的发展历程**

   - 软件危机：
     - 软件开发进度和成本难以控制
     - 软件产品难以满足用户的需求
     - 软件质量难以得到保证
     - 软件产品难以进行维护
     - 软件的文档资料难以管理
     - 软件产品的生产率难以得到提高
   - 软件危机出现的原因：
     - 对软件开发缺乏争取的理论指导
     - 软件人员与用户缺乏充分交流
     - 对软件开发过程缺乏整体认识
     - 对软件产品缺乏有效一致的质量评价标准
   - 软件开发的错误观念：
     - 开发软件就是编程
     - 只要向用户提交了程序，并且可以运行，软件开发工作即告结束
     - 软件是灵活的，可以很容易修改
     - 增加人员可以加快进度
   - 软件工程的发展：
     - 第一代软件工程——传统软件工程阶段
     - 第二代软件工程——面向对象软件工程阶段：也称对象工程
     - 第三代软件工程——过程工程的软件阶段：要保证软件开发过程的可控性和软件质量的可靠性，关键是要对软件过程进行管理和控制
     - 第四代软件工程——构件工程的软件工程阶段：软件的重用和软构件技术逐步成为软件工程研究和发展的主要内容

2. **软件工程的概念**

   - 软件工程的定义：

     - IEEE 定义：将系统的、规范的可度量的工程化方法应用于软件开发、运行和维护的全过程及上述方法的研究

     - 软件工程包括三个要素：方法、工具和过程
     - 软件开发活动的两个主要方面：工程学、软件生产过程

   - 软件工程的特性：
     
     - 软件开发活动必须是系统的、规范的和可度量的
     - 软件工程关注所有软件活动的展开
     - 软件工程支持软件活动中与内部的协同开发
     - 软件工程强调软件活动中与外部的交流沟通
     - 软件工程为高质量、高效率开发软件提供了理论基础和应用途径
     
   - 软件工程的目标：

     跟踪最新的软件技术发展，修改和制定新的软件开发活动规则，提高和规范软件管理的效率和可操作性，确保软件质量，在有限的时间、人力、物力、财力的基础上，生产出符合用户需求的软件产品，提高软件生产率

   - 软件质量的衡量标准：
     - 可理解性：对软件体系结构、数据、程序的描述清晰和易于掌握的程度
     - 功能性：软件所实现的功能和达到性能与满足用户实际需求的程度
     - 安全性：软件具有的自身保护能力的程度
     - 可靠性：软件在给定时间、空间、外部环境等条件下，按照设计要求，成功运行的能力
     - 有效性：软件能充分利用计算机时间、空间、带宽等资源的能力
     - 可扩充性：软件在功能或性能发生变化时，改变系统的容易程度
     - 可维护性：软件出现异常时，对系统进行修改、改进、删除、增加等操作，并恢复系统正常运行的能力
     - 可重用性：软件的部分或整体被其他系统利用的程度
     - 可移植性：将软件系统由一个软件或硬件环境转移到另一个软件或硬件环境的容易程度
   - 软件工程的实施原则：
     - 做好全面的用户需求分析
     - 选取适宜的开发模型
     - 采用成熟的设计方法
     - 选择高效的开发环境
     - 保证有效的维护过程
     - 重视软件过程管理
   - 软件工程的基本原理：
     - 用分阶段的生命周期计划严格管理
     - 坚持进行阶段评审
     - 执行严格的产品质量控制
     - 采用现代程序设计技术
     - 结果应能清楚地审查
     - 开发小组的人员应该少而精
     - 承认不断改进软件工程实践的必要性

3. **软件与软件过程**

   - 软件的概念：

     软件是指计算机系统中与硬件相互依存的另一部分，包括程序、数据及相关文档的完整集合

   - 软件的特点：

     - 软件是逻辑实体而非物理实体
     - 软件是智力产品，生产的过程主要集中在研发上
     - 软件永不磨损，但它会退化，直至被放弃使用
     - 软件开发远未达到软件工程目标提及的产业化生产
     - 软件越来越复杂，今后将会更加复杂

   - 软件的分类：

     - 系统软件
     - 支撑软件
     - 实时软件
     - 嵌入式软件
     - 人工智能软件
     - 应用软件

   - 软件生命周期：

     - 可行性与计划阶段
     - 需求分析阶段
     - 设计阶段
     - 实现阶段
     - 测试阶段
     - 运行和维护阶段

   - 软件过程：

     - 过程定义
     - 过程实现与变更
     - 过程评估
     - 过程与产品度量

4. **软件过程模型**

   - 瀑布模型：

     - 概述：是一个典型的线性模型：由可行性分析与计划入手，依次进行需求分析、设计、编码、测试和运行维护
     - 特点：
       - 简单：降低了大型软件开发的复杂性
       - 严格
       - 顺序：没有完成本阶段任务时，不能开始后续阶段的工作
       - 一次性：没有迭代开发
       - 质量保证：强调文档的作用
     - 缺陷：
       - 由于是一次性单向开发，难以适应软件需求不明确或出现变动的情况
       - 由于其顺序性，用户只有在软件开发结束后才能得到最终结果，增大了开发的风险

   - 原型模型：

     - 概述：软件人员根据用户初步的、不明确的需求快速开发出系统原型，用户根据原型进一步明确到底要做什么，软件人员也进一步确定用户需求
     - 适用场景：不适宜开发大型软件项目
     - 特点：
       - 快速：用户不用等到软件全部实现就能看见和使用系统
       - 符合用户预期
     - 缺陷：由于最初的原型模型可能离用户最终的系统差别很大而被抛弃，并且被抛弃的系统原型模型的开发成本也影响到原型模型的采用

   - 增量模型：

     - 概述：对于系统整体需求，增量模型先将需求分解为若干部分，每部分都按照瀑布模型进行开发
     - 适用场景：需求不明确、开发功能多、开发时间长的系统
     - 特点：
       - 灵活性：由于软件开发是以系统的一个子集来进行的，用户能尽早对系统有直观认识
       - 降低风险：即使系统出现错误，但由于用户尽早地参与开发过程，从而使得错误的影响范围有限

   - 螺旋模型：

     - 概述：将原型模型与瀑布模型相结合，并引入风险分析机制
     - 适用场景：大型复杂项目
     - 特点：
       - 风险分析：螺旋模型首次采纳风险分析，让开发者和客户能较好地对待和理解每一次迭代所带来的风险，降低软件开发中的技术、管理和成本的风险
       - 特别适应大型复杂系统的开发，能及时发现开发过程中出现的风险，并能尽早规避风险，或给出消除风险的方案
     - 缺陷：螺旋模型强调风险分析，这需要具有一定的风险分析评估技术，且成功依赖于这种技术。因此，要求软件人员在每次迭代开始前，需要分析和找到软件开发中的风险，从而提前采取解决风险的策略，否则会给软件开发带来更大风险

   - 喷泉模型：

     - 概述：喷泉模型最大的特点在于软件过程中的每个阶段相互重叠，而不像其他过程模型那样每阶段有明显界限
     - 适用场景：主要用于面向对象软件开发，并支持重用
     - 特点：
       - 开发阶段的相互重叠：不仅反映了软件开发的并行过程，也体现了面向对象方法中分析、设计和实现之间无明显界限，各阶段平滑过渡的特点
       - 支持重用：各阶段结果不仅支持下一阶段的开发活动，也支持向下往复过程时分析、设计内容和模式的重用
       - 不严格的阶段划分，增量式开发
       - 对象驱动：对象是重用的基础，是整个过程的实体
     - 缺陷：由于喷泉模型各阶段的并行，导致需要较多的软件人员参与到开发过程中，这给管理带来一定困难，同时也加大了文档的审核和管理困难

   - 敏捷模型：

     - 价值观：
       - 个体和交互胜过过程和工具
       - 可以工作的软件胜过面面俱到的文档
       - 客户合作胜过合同谈判
       - 响应变化胜过遵循计划
     - 原则：
       - 简单
       - 变化
       - 建模
       - 交流
       - 反馈
     - 类型：Scrum、极限编程和测试驱动
     - 特点：
       - 综合瀑布模型和原型模型的优点，在保证减少错误的前提下，快速得到用户系统。在每阶段的活动中，都引入风险分析，极大降低潜在的系统风险
       - 快速开发、建模，不但能够促进个人和团队开发人员之间的交流，还能促进个人和其他人员的交流

     - 缺陷：
       - 在确认订单产品中，由于缺乏充分的需求分析以及风险评审，会造成没能发现某些错误，而对开发后续阶段的工作甚至是整个系统开发带来灾难
       - 对于开发全新的软件系统，由于功能、接口、界面等因素的不确定性较大，导致后续的修改、测试等返工的工作量较大
       - 由于快速搭建原型，没有在系统架构上进行严谨的设计，导致后期的代码管理、维护等过程复杂性增加

   - 渐进交付迭代模型：

     - 概述：随着软件规模的增大、功能的增加、架构的复杂而提出来的过程模型。面对不明 确的需求(原型模型)、非整体的开发(增量模型)、影响软件质量的风险(螺旋模 型)，迭代模型通过对整个软件系统不断演进的循环往复，完成软件系统的实施过程
     - 特点：
       - 最小功能集合
       - 最小开发成本
       - 及时的用户反馈
       - 强调系统的核心功能
     - 缺陷：对于大型复杂系统，就很难做到开发出最小可用的系统而后再不断扩展功能。同样，对于需求明确的系统来讲，也不适宜采用该模型进行开发

   - 微软解决框架过程模型（MSF）

   - 软件过程模型的比较：

     | 软件生命周期模型 |                         优势                         |                     不足                     |
     | ---------------- | :--------------------------------------------------: | :------------------------------------------: |
     | 瀑布模型         |        总揽全局，明确需求，文档规范，过程严谨        |              难以适应需求的变更              |
     | 原型模型         |    通过原型开发和讨论，逐步明确问题定义和系统需求    |           原型的开发会增加系统成本           |
     | 增量模型         | 系统核心功能明确，实现最小可用系统为前提，再后续扩展 |      需要各类人员广泛参与，增加管理难度      |
     | 螺旋模型         |        增加风险分析，最大限度减少系统开发风险        | 风险分析策略需要分析人员具有经验，有一定难度 |
     | 敏捷模型         |              快速开发，及时响应用户反馈              |     缺乏细致准备，会造成后续维护变更困难     |
     | 渐进交付迭代模型 |       通过不断演进往复，完成软件系统的实施过程       |        对大型系统难以做到最小应用开发        |
     | MSF 模型         |          同步和稳定策略推动项目、技术的成功          |         较少在微软之外的公司得到推广         |

5. **软件开发方法**

   - 概述：

     软件开发方法是用已定义的过程、方法和工具，在技术上和管理上来组织软件生产的一系列活动。其中，过程用于定义软件开发顺序的操作流程，方法是用软件开发理论和规范的技术手段来设计软件，工具提供了方法中可用的一组图形符号，这些图形符号有各自的语法和语义信息

   - 结构化开发方法：

     也称为面向功能的软件开发方法或面向数据流的软件开发方法

     首先用结构化分析（Structure Analysis, SA）对软件进行需求分析，之后用结构化设计（Structure Design, SD）进行系统设计，最后用结构化编程（Structure Programming, SP）实现软件

     结构化开发方法提出的开发过程步骤明确，SA、SD 和 SP 三个阶段彼此衔接，前后照应。提高了软件开发效率和质量，降低了错误率

     结构化设计 = 数据结构 + 算法

   - 面向对象开发方法：

     面向对象分析（OOA）和面向对象设计（OOD）

     面向对象 = 对象 + 类 + 继承 + 消息

### 软件需求工程

1. **软件需求的基本概念**

   - 需求分析的任务：

     - 确定系统将要实现的各项要求
     - 数据分析
     - 定义逻辑模型
     - 适应需求变更

   - 需求分析的原则：

     - 软件人员要从用户的角度考虑软件需求
     - 以流程为主线
     - 尽量重用
     - 划分需求的优先级
     - 需求变更要及时反馈

   - 需求分析的内容：

     - 功能需求：

       描述系统提供的服务和在特定条件下的行为，包括系统登录、输入、响应、输出、异常等，有时还需要特别说明系统不应该做什么

       软件的功能描述应满足完整性和一致性。完整性要求需求分析覆盖所有用户提出的服务。一致性要求功能需求不能有相互矛盾之处

     - 性能需求：

       规定了软件系统必须满足在时间上或空间上的约束，通常包括系统响应时间、主存容量、存储容量、安全性、压力等方面的需求

     - 领域需求：

       与软件系统的具体应用范围有关，它是对需求中的功能或数据在领域上需要的特别实现，具有特殊性

     - 其他需求：

       是与软件系统有关的外在约束，如法律需求、道德需求、外部数据交换需求、预期需求等

2. **可行性分析**

   - 概述：

     力求用最小的代价、在尽可能短的时间内确定问题是否能够解决。可行性分析的目的，不是确定问题如何去解，而是确定问题是否值得去解

   - 可行性分析的内容：

     - 经济可行性：代码行技术、功能点技术
     - 技术可行性：问题的复杂性、现有技术、技术所需代价、技术风险
     - 操作可行性
     - 法律可行性

   - 系统流程图（SF） :book:（P38）

3. **需求工程的过程**

   - 需求工程中的参与人员
   - 需求工程中的活动：
     - 需求获取
     - 需求分析与建模
     - 需求评审
   - 需求工程的管理：
     - 两大难题：需求确认困难；需求不断变更

4. **需求获取技术**

   - 个别会谈与小组会议
   - 问卷调查
   - 面向用例的场景分析
   - 快速原型技术

5. **结构化需求分析和建模**

   - 概述：

     主要目的是为了减少需求分析时的错误，通过自顶向下建立系统逻辑模型，降低系统设计时的复杂性，提高系统的可维护性

   - 结构化需求分析概述：

     核心是数据。数据包括在分析、设计和实现中涉及的概念、术语、属性等所有内容，并把这些内容定义在数据字典中。围绕数据字典，完成功能模型、数据模型和行为模型的结构化建模过程

   - 面向数据的数据建模 :book:（P45）​：

     实体关系模型图（ER）

   - 面向数据流的功能建模 :book:（P47）：

     数据流图（DFD）：

     - 数据源：是系统的外部接口，它表明系统数据的来源及系统结果的去向。数据源可以是人（用户）、其他系统。在不同层次的 DFD 中，数据源是不能改变的
     - 数据加工：是系统的变换部分，表明不同数据是通过哪些功能完成的变换。数据加工通过 DFD 的分层来分解，细化对数据的变换过程
     - 数据存储：是在 DFD 中保存数据，数据结果既可以是临时文件，也可以是持久文件
     - 数据流是有方向的，表明数据变换是可追溯的过程。数据流箭头上必须给出数据流信息，说明数据加工之间的信息传递

   - 面向状态转换的行为建模 :book:（P51）：

     - 状态转换图（STD）：
       - 状态：状态是可观察到的行为，是同一数据对象在系统的不同运行时刻所具有的行为属性值，是事件触发后一系列动作的结果
       - 转换：由一个状态转换到另一个状态的关联就是状态转换
       - 事件：是指在某一时刻发生的事情，是触发状态转换的条件或一系列动作
     - 过程描述语言（PDL）或伪代码语言（PL）

6. **数据字典（DD）**

   - 概述：

     数据字典以结构化方式定义了在数据建模、功能建模和行为建模过程中涉及的所有数据信息、控制信息，包括数据的含义、类型、范围、单位、精度等完整、准确、一致的定义

     数据字典是需求规格说明中的重要组成部分，它规范了整个软件开发过程中数据信息、控制信息等各类数据的定义和组织，具有广泛的指导意义

   - 数据字典的编写要求：

     - 数据字典设计原则：
       - 应按照统一的数据字典定义形式来编写数据字典
       - 应以应用为基础
       - 应确保数据字典定义的完整性
       - 应确保数据字典定义的一致性
     - 数据字典编写规范：
       - 数据编号规范
       - 数据命名规范
       - 数据命名缩写规范

   - 数据字典的定义 :book:（P55）：

     - 词条描述
     - 定义式
     - 数据表

7. **需求评审**

   - 软件需求规格说明（SRS）：

     描述用户的功能需求、性能需求、领域需求，以及对软件、硬件环境等约束，明确定义系统的安全性、可靠性、可操作性的性能指标，确保用户需求描述的完整性、一致性、可验证性和可追踪性等特性

   - 数据需求说明（DRD）：

     描述在软件生命周期内所处理的数据，包括数据采集、数据存储、数据结构等的技术信息

   - 需求评审标准及需求验证：
     - 正确性
     - 完整性
     - 一致性
     - 可行性
     - 可理解性
     - 可验证性
     - 可修改性
     - 可追踪性
   - 需求变更管理：
     - 确定需求基线
     - 需求变更影响分析
     - 需求变更维护记录
     - 需求变更的稳定性、可控性和延续性

### 软件设计基础

1. **软件设计概述**

   - 软件设计与软件需求：

     软件设计是需求工程的后续阶段，它根据所描述的信息域需求（包括功能需求、性能需求、领域需求、数据需求等）的定义，进行数据设计、体系结构设计、界面设计和过程设计

     软件设计不是编码，编码只是设计的具体实现过程，代码把设计人员的思路物理地表现出来。只有良好的软件设计，才是代码实现并优化的基础和根本

   - 软件设计的任务：

     - 概要设计：
       - 体系结构设计
       - 界面设计
       - 数据设计
     - 详细设计：过程设计

   - 软件设计的原则：

     - 分而治之
     - 重用设计模式
     - 可跟踪性
     - 灵活性
     - 一致性

2. **软件体系结构设计**

   - 体系结构设计概述：

     - 定义：软件体系结构为软件系统设计提供了一套关于数据、行为、结构的指导性框架，该框架提供了描述系统数据、数据间关系的静态特征，还对数据的操作、系统控制和通信等活动提供具有动态特征的描述过程
     - 作用：
       - 提供软件设计师能预期的体系结构描述
       - 数据结构、文件组织、文件结构体现了软件设计的早期抉择，这些抉择将极大地影响着后续的软件开发人员，决定着软件产品的最后成功

   - 以数据为中心的数据仓库模型：

     - 优点：
       - 数据统一存储和管理，确保了数据的实时性
       - 数据仓库对数据复杂性的统一封装，有利于数据共享
       - 采用黑板模型，与某类数据有关的应用系统能及时获取数据
       - 采用数据订阅推送模型，应用系统在有数据更新时，能主动获得数据，而不用采取询问方式，这就提高了数据管理效率
       - 各应用系统间仅通过数据仓库完成数据交换，在功能上没有关联，增加、删除应用系统及其部分功能，不会影响其他应用系统的正确运行
     - 不足：
       - 如果对数据仓库数据进行操作，不同应用系统的数据视图必须统一，否则难以达到数据共享的目的，但这不可避免地会降低各应用系统的效率
       - 如果应用系统的数据结构发生改变，就需要单独设计数据适配器，以实现新的结构与数据仓库在数据上的匹配
       - 随着网络技术的发展，数据共享带来的访问控制的复杂性、安全性、效率、备份、存储、恢复策略等一系列问题，影响了仓库模型的有效利用

   - 客户端 / 服务器模式的分布式结构：

     - 类型：
       - 两层结构：隐含多层的逻辑划分：应用系统交互、系统逻辑功能和数据访问
       - 三层结构：
         - 胖客户端
         - 瘦客户端
         - 折中
       - 多层结构
     - 优点：
       - 共享：数据共享、计算共享
       - 异构性：客户端和服务器允许软硬件配置不同
       - 开放性：符合互联网协议的设备都可以接入
       - 易修改性：易于系统的修改和维护
       - 透明性：只需要知道服务器的服务位置，而对后端的逻辑实现、数据存储、数据访问等不必清楚其架构和访问方式
     - 不足：
       - 复杂性
       - 安全性：身份验证困难
       - 运行状态难以确定

   - 层次模型：

     每个层次提供单向服务。适合增量式开发

   - MVC 模型：

     - 组成：
       - 模型：是系统的主体部分，使用系统处理数据的数据规则和使用控制逻辑的业务规则。当控制器需要提交系统任务时，会调用相应模型来实现。当模型得到结果后控制器会将结果传递给视图，由视图完成对结果的展示
       - 视图：完成对数据的展示。但不包括应用系统的任何数据规则和业务逻辑
       - 控制器：定义了应用程序的行为，它负责对用户的请求进行解析
     - 优点：
       - 一个模型对应多个视图：提高模型的可重用性，也易于维护
       - 模型的自包含性：模型包括系统所有的数据和逻辑操作，对数据和功能的修改，都在模型内部完成，不涉及视图的变化、控制器的判断
       - 控制层把一个模型和多个不同视图组合在一起，能够完成多种类型的请求
       - MVC 分层模式，使得只需修改其中某层，就能满足用户新的需求
       - MVC 有利于软件工程的工程化管理
     - 不足：
       - 增加系统的复杂性
       - 导致修改的连锁反应
       - 数据访问效率低

3. **模块化设计**

   - 软件模块化与分解：

     问题总的复杂读会随着模块分解而趋于减小，工作量也同时减少。但如果模块分解过程无限进行下去，不仅问题的复杂度不会减少，相反还会增加

   - 抽象：

     - 实体抽象
     - 接口抽象
     - 设计模式抽象

   - 信息隐藏：

     信息隐藏是把数据结构和实现过程放在一起，对外提供相对完整、独立的功能，对隐藏信息的访问只能通过接口进行操作

     信息隐藏提高了软件的可修改性和重用性

   - 模块独立性：

     - 内聚性：

       内聚性是指模块数据与操作之间的紧密程度

       内聚性越强，模块内部元素之间关系越紧密，模块独立性就越强

       - 偶然内聚：模块内的功能因为一些偶然的因素聚集在一起，它们之间咩有必然联系。可以将其拆分
       - 逻辑内聚：将逻辑上相关的功能放在同一模块内
       - 时间内聚：各个任务间彼此并无联系，但由于需要在同一时间运行而聚集在一起
       - 过程内聚：模块内部必须按照过程描述，在同一模块自上而下地组织各任务。过程内聚比时间内聚要好
       - 通信内聚：模块中各成分饮用共同的数据，即模块内的功能使用同一输入数据，或共同输出同一数据
       - 顺序内聚：在模块的各部分中，前一部分的输出是下一部分的输入，它们彼此具有较高的依赖性
       - 功能内聚：模块内各部分共同完成一个具体的功能，它们之间紧密联系，不可分割，具有最高的内聚性

     - 耦合度：

       耦合度是指模块间的紧密程度

       耦合度越低，模块间的紧密程度越松散，模块独立性就越强

       - 非直接耦合：模块间没有直接的相互调用关系。是最松散的耦合关系
       - 数据耦合：模块间相互调用时，传递的是基本数据类型，而非复合数据结构。是最理想的耦合形式
       - 特征耦合：模块间相互调用时，传递的是复合数据结构而非基本数据类型
       - 控制耦合：模块间传递数据不是普通的值信息，而是控制变量。增大了模块间相互依赖关系，降低了相互依赖模块的可重用性
       - 公共耦合：多个模块访问全局变量、结构、文件等公共信息都称为公共耦合
       - 内容耦合：一个模块直接访问另一个模块内部中的数据，或一个模块有多个入口，或一个模块非法进入另一个模块内部

       考虑模块耦合度时，应遵循“尽量使用数据耦合，少用控制耦合，限制公共耦合范围，坚决避免使用内容耦合”

   - 启发式规则：

     - 改进软件结构，提高模块独立性:
       - 进行模块的分解和合并
     - 模块规模适中
     - 软件结构的宽度、深度、扇出度和扇入度都应适中：
       - 宽度：是指软件结构中同一层次上模块数目的最大值。宽度越大，软件复杂度越高
       - 深度：是指同一模块能控制的最深的层数。深度越大，模块分解也就越细，软件复杂度就越高
       - 扇出度：是指软件结构中同一模块能直接调用的其他模块数目。模块的扇出度越大，说明该模块的控制结构就越复杂
       - 扇入度：是指软件结构中模块被直接调用的模块数目。模块的扇入度越大，说明该模块被共享的次数越多，则该模块的独立性也较强
     - 模块的作用域应在模块控制域之内
     - 设计单入口、单出口的模块，并力争降低模块接口的复杂度
     - 模块功能可以预测

4. **界面设计**

   - 界面设计的任务：
     - 用户特性分析
     - 用户工作分析
     - 界面任务分析
     - 界面类型确定
     - 界面原型评估
   - 界面设计的原则：
     - 系统所有界面操作的统一
     - 提供系统运行过程中必要的反馈信息
     - 提供快捷方式和回滚操作
   - 界面设计的特性：
     - 简易性
     - 帮助性
     - 容错性
     - 灵活性
     - 个性化

5. **软件设计评审**

   - 软件设计规格说明：
     - 软件结构设计说明（SDD）
     - 数据库设计说明（DBDD）
     - 接口设计说明（IDD）
   - 软件设计评价标准：
     - 与软件规格说明的契合度
     - 对软件设计规格说明文档评审的标准
     - 对整个软件设计合理性的评审标准
   - 软件设计验证：
     - 验证软件设计承上启下的作用
     - 验证软件设计与需求规格说明的对应
     - 验证模块设计的适用性
     - 验证数据设计的合理性

### 结构化设计方法

1. **结构化设计方法概述**

   - 概述：

     结构化设计（SD）的基础是模块

     机构化设计的基本思想是：基于模块独立性和信息隐藏原则，自顶向下，逐步求精，分解与抽象相结合，并应用结构化程序设计技术而进行的软件设计

   - 变换分析法：

     在数据流图中，基本的系统数据流经过输入、系统变换、输出，完成对数据的分析处理

   - 事务分析法：

     事务分析法是特殊的变换分析法，它的典型特征在于数据流图中有一个“事务中心”，它处理从多条变换输出路径中选择一条活动路径，具有这种选择处理能力的加工逻辑(模块)就称为事务中心

   - 混合分析法：

     在一个大型系统的数据流图中，变换流和事务流会同时出现。按照结构化设计中分解的思想，上层数据流图整体反映一个主题：变换流或事务中心。在对数据流图分解的下层图或各条路径活动中，再确定变换流或事务中心。如此往复迭代，形成混合分析法

2. **面向数据流的设计方法**

   - 层次图和结构图：
     - 层次图（HD）:book:（P101）
     - 结构图（SC）:book:（P101）：
       - 传入模块
       - 传出模块
       - 变换模块
       - 协调模块
   - 变换分析法 :book:（P102）
   - 事务分析法 :book:（P106）
   - 混合分析法 :book:（P107）

3. **结构化详细设计的工具**

   - 程序流程图（PFC） :book:（P111）
   - 盒图（N-S） :book:（P113）
   - 问题分析图（PAD） :book:（P114）
   - 判定树 :book:（P115）
   - 判定表 :book:（P116）

### 软件实现

1. **程序设计语言**
   - 程序设计语言的分类：
     - 第一代计算机语言——机器语言
     - 第二代计算机语言——汇编语言
     - 第三代计算机语言——高级语言：C++、Java
     - 第四代计算机语言——4GL：SQL
   - 程序设计语言的特性：
     - 一致性
     - 二义性
     - 局部性
     - 易编码性
     - 可移植性
     - 可维护性
   - 选择程序设计语言：
     - 结构化程序设计语言机制：
       - 数据结构的显式表示
       - 模块化编程
       - 控制结构
     - 面向对象程序设计语言机制：
       - 类
       - 继承性
       - 多态性
       - 消息机制
     - 选择程序语言的准则：
       - 工程项目规模
       - 开发和维护成本
       - 编程人员对程序语言的熟悉程度
       - 项目的领域背景
2. **程序设计风格**
   - 程序编排和组织的准则
   - 程序设计的效率
3. **代码重用**
   - 源代码形式的重用
   - 库文件形式的重用
   - 面向对象机制下的重用
4. **代码评审**

### 软件测试

1. **软件测试基础**

   - 软件测试概念：

     - 失败：当程序不能运行时称为失败。失败是系统执行过程中出现的一种情况，它源于编码错误

     - 错误：程序运行而得不到正确结果

     - 缺陷：是错误的表现。如叙述的不完整、数据流图的不平衡、程序流程图

       的非结构化设计、源代码编写错误等

     - 测试用例：是为了某种特定目标而设计的一组输入数据或执行条件， 以及预期结果的集合。它是测试执行时最小的实体

     - 测试只能证明程序有错，而不能保证程序无错

     - 一个好的测试用例和过程可能发现一个尚未发现的错误

     - 一个成功的测试用例是发现了一个尚未发现的错误

   - 软件测试过程模型：

     - 测试的 V 模型：V模型的重要价值在于，它定义了软件测试如何与软件工程各阶段相融合，它清楚地描述了各级别软件测试与软件开发各阶段的对应关系
     - 测试的 W 模型：W模型的重要贡献在于，明确软件开发各阶段都要进行测试，而不仅仅是在编码结束后才开始。这样，测试的对象不仅是代码，还可以是文档（需求规格说明、设计规格说明等）
     - 测试的 H 模型：软件测试的H模型是对W模型在更高层次上的线性抽象。它明确表示，在任何一个开发流程，只要有必要，并且测试配置已准备就绪，就能进行测试活动

   - 软件测试原则：

     - 应尽早地和不断地进行测试
     - 开发人员应尽量避免参加测试
     - 注重测试用例的设计和选择
     - 增量式测试
     - 充分注意测试的群集现象
     - 合理安排测试计划，严格执行测试计划
     - 全面统计和分析测试结果
     - 保存测试文档，并及时更新

   - 软件测试技术分类：

     - 静态测试和动态测试：
       - 静态测试的测试对象包括源程序和文档。项目开发过程中产生大量的规格说明，对这些规格说明的技术审查和管理复审，以及对文档的测试数据都属于静态测试
       - 动态测试的测试对象针对源程序。就源程序来讲，静态测试是指不运行程序就找出程序中存在的错误，动态测试是通过运行程序而发现存在的错误和问题
     - 黑盒测试和白盒测试：
       - 白盒测试是针对模块内部逻辑结构进行的测试。它面对程序内部的实现细节，分别对语句、条件、条件组合、循环等控制结构、异常、错误处理等特殊流程设计测试用例
       - 黑盒测试是把模块作为一个整体进行测试。它不关心程序逻辑实现的具体细节，而是关注模块的输入（接口）、输出（运行结果）。因而它测试的是模块功能是否符合设计，运行时是否能（被）正确调用
     - 测试策略与过程划分：
       - 单元测试
       - 集成测试
       - 确认测试
       - 系统测试

2. **白盒测试**

   - 逻辑覆盖：
     - 语句覆盖：
       - 是最弱的逻辑覆盖
       - 对于判定、条件、路径都没有涉及
     - 判定覆盖：
       - 仅考虑逻辑表达式的整体取值，没有考虑各子关系表达式的取值，因而无法发现各子条件中存在的错误
     - 条件覆盖：
       - 每个判定中的每个子关系表达式的取值至少各执行一次的覆盖
       - 测试用例较多，同时也不能完全涵盖判定覆盖
     - 条件 / 判定覆盖：
       - 所有判定的各分支至少执行一次，判定中的每个子关系表达式的取值也至少各执行一次
       - 测试用例较多，同时也不能完全涵盖路径覆盖
     - 条件组合覆盖：
       - 每个判定中的各子关系表达式的取值组合至少执行一次的覆盖
       - 设计大量复杂的测试用例，工作量较大
   - 循环测试 :book:（P150）
     - 简单循环
     - 顺序循环
     - 嵌套循环
   - 路径测试：
     - 流图 :book:（P152）
     - 环形复杂度：设 $E$ 为流图 $G$ 中边的总数，$N$ 为 $G$ 中点的总数，则 $G$ 的环形复杂度 $V(G)$ 的计算公式为：$V(G)=E-N+2$
     - 测试流程：
       - 根据设计过程得出相应流图
       - 计算流图的环形复杂度：环形复杂度确定有几条独立的测试路径
       - 确定线性独立路径集合

3. **黑盒测试**

   - 等价类划分
   - 边界值分析
   - 因果图法

4. **软件测试策略**

   - 单元测试：

     单元是软件测试过程中最小的测试单位，它有两个基本属性：- 

     - 单元是可以独立编译的最小组件（函数、接口、类）

     - 单元是由个人开发的软件组件（菜单、界面）

   - 集成测试：

     集成测试是指在完成单元测试后，将各单元模块依据设计的软件系统结构，按照一定的集成测试策略进行组装的过程

     集成测试策略 :book:（P165）：

     - 非渐增式集成
     - 渐增式集成：
       - 自底向上：
         - 优点：驱动模块较易编写，且能够尽早查出底层涉及较复杂的算法和实际的 I/O 模块中的错误
         - 缺点：最后才能发现系统主控方面的问题
       - 自顶向下：
         - 优点：能够尽早发现系统主控方面的问题
         - 缺点：无法验证桩模块是否完全模拟了下属模块的功能

     集成过程的原则：

     - 尽早测试关键模块
     - 尽早测试包含 I/O 的模块

   - 确认测试：

     确认测试也称为验收测试，它是指在模拟用户实际操作的环境下（或开发环境下），运用黑盒测试法验证软件的有效性是否符合需求

   - 系统测试：

     系统测试是指软件系统作为整个计算机系统的一部分，与计算机系统的硬件系统、数据、外部其它软件、文档等要素相结合，在用户实际运行环境中进行的确认测试

     系统测试的内容：

     - 压力测试：压力测试也成为强度测试，是指系统在各种资源超负荷得情况下对运行状况进行测试
     - 容量测试：容量测试是面向数据的测试，是指在系统运行时超额处理大数据量时的能力

     分类：

     - α 测试：是在开发环境下，由用户和软件开发人员、测试人员共同对系统进行的测试
     - β 测试：是系统实际用户使用环境下进行的测试，并且整个测试过程都是用户独立进行，不受开发人员和测试人员的影响

5. **调试**

   - 确定软件系统出现错误的准确位置
   - 对发现错误的修改
   - 对修改后的内容重新进行测试

### 统一建模语言 UML

1. **UML 的发展**

2. **面向对象的基本概念**

3. **UML 视图**

4. **UML 的图和模型元素**

   - 用例图：

     用例图是从系统外部描述系统的功能及系统间关系，它主要用于子系统、包、类等的功能行为描述。用例图不负责描述功能实现的细节和性能的约束。包括：

     - 参与者
     - 用例
     - 系统边界
     - 关系

   - 类图：

     类图用于描述类的属性、方法和类间关系。属性和方法是类的内部结构，关系是类间的关联，它们用于定义 UML 的静态模型。包括：

     - 类名
     - 可见性
     - 属性
     - 方法

   - 包图：

     包图是对 UML 中用例图、类图、UML 关系等模型元素的封装，它用于描述具有相似功能的模型元素的组合，或组织软件系统结构的层次，或展现整个系统的物理部署。通过包图，能对语义上相关的图形元素进行分组，简化系统结构描述，提高系统设计和实现的模块化程度，同时降低各子系统间的耦合度

   - 状态图：

     状态图用于描述一个对象在生命周期内的所有可能的状态，以及引起状态改变的事件或条件

   - 活动图：

     活动图用于描述用例或场景的活动顺序，或描述一个活动到另一个活动的控制流。活动图所描述的内容可以是类内部的处理流程，也可以是整个软件系统的操作流程。活动图反映在系统功能逻辑中参与的对象，以及每个对象各自的行为活动

   - 顺序图（序列图）：

     用于描述对象间的动态协作关系，并着重表现在时间先后顺序上，多个对象是如何进行交互的。包括：

     - 参与者
     - 对象
     - 对象的生命线
     - 消息

   - 协作图（合作图）：

     用于描述类和类间关系，反映的是通过一组类的共同合作来完成系统功能。包括：

     - 对象
     - 链接
     - 消息

   - 构件图（组件图）：

     用于描述软件系统代码的物理组织结构，该结构用代码组件表示。代码组件可以是源代码、二进制文件、目标文件、动态链接库、COM 组件或可执行文件、数据和相关文档等

   - 配置图（部署图）：

     用于描述软件系统在硬件系统中的部署，反映系统硬件的物理拓扑结构，以及部署在此结构上的软构件分布。包括：

     - 节点
     - 连接
     - 构件

5. **UML 的关系**

   - 关联关系：

     类与类之间的关系称为关联，对象与对象之间的关系称为链。链是关联的实例

     如果类之间能彼此通信，这些类之间就存在关联关系

     - 普通关联
     - 限定关联
     - 关联类
     - 递归关联
     - 聚合关联

   - 泛化关系（继承关系）：

     - 普通泛化
     - 受限泛化

   - 依赖关系

   - 实现关系

6. **UML 的通用机制**

### 面向对象分析

1. **面向对象分析概述**

   - 概述：

     是以类和对象为基础，以面向对象方法学为指导，分析用户需求，并最终建立问题域模型的过程

   - 传统软件过程中的不足：

     - 需求分析与设计在描述和表示上的不一致
     - 对编程和测试带来的问题
     - 对维护带来的问题

   - 面向对象的特点：

   - 面向对象分析的基本过程：

   - 面向对象分析的 3 类模型：

     - 功能模型
     - 静态模型
     - 动态模型

   - 静态模型的 5 个层次：

     - 类-对象层
     - 结构层
     - 属性层
     - 服务层
     - 主题层

2. **建立功能模型（用例模型）**

   - 识别参与者
   - 识别用例
   - 识别用例间关系
   - 用例描述文档

3. **建立静态模型（对象模型）**

   - 识别类与对象
   - 划分主题
   - 确定结构
   - 确定属性
   - 确定服务

4. **建立动态模型**

   - 建立顺序图及其描述文档 :book:（P229）
   - 建立状态图及其描述文档 :book:（P231）
   - 建立协作图及其描述文档 :book:（P232）
   - 建立活动图及其描述文档 :book:（P233）

### 面向对象设计

1. **面向对象设计概述**

   - 面向对象分析与设计的关系：
     - 与OOA和OOP共同构成面向对象开发的整个过程链，全面体现面向对象特点
     - OO强调对象结构而不是程序结构，增加了信息共享的机制，提高了信息共享的程度
     - OOD的设计过程要与OOP所选用的编程语言相结合，因为不同的面向对象编程语言对面向对象机制的支持程度不尽相同
     - 因为OOA和OOD的过程都使用UML语言来描述，因而过程间的转换不需要任何映射方法和转换步骤，更有利于各阶段间转换和分析结果的复用
   - 面向对象设计原则：
     - 信息隐藏与模块化
     - 重用：
       - 代码重用
       - 设计模式重用
     - 单一原则
     - 规划和统一接口，不要急于考虑细节问题
     - 优先使用聚合
     - 开放封闭原则

2. **精化类及类间关系**

   - 设计类的属性
   - 设计类的方法
   - 设计类间泛化关系
   - 设计关联类

3. **数据设计**

   - 基于关系数据库的数据设计：
     - 关联关系的数据设计
     - 泛化关系的数据设计

4. **设计模式简介**

   - 概述：

     设计模式是指一套经过规范定义的、有针对性的、能被重复应用的解 决方案的总结。使用设计模式是为了更有效地重用原有代码，使得代码重 用有章可循，增加软件结构和代码的可理解性，增强代码的可靠性

   - Singleton 模式：

     使得系统运行时仅有一个受约束的实例存在，降低系统控制 的复杂度，避免由于产生多个对象而造成的混乱

   - Abstract Factory 模式：

     提供一个获得不同类的对象的方法

   - Mediator 模式：

     通过定义中介类的方式处理类间复杂的交互关系，也能消除类间多对多的关联关系

     降低类间的耦合度

     使得类的设计集中于自身功能的实现，以提高类的内聚性

     由于中介类的存在，使得如果类间关系发生改变时，主要的修改发生在中介类，而对类自身的影响降到最小

   - Adapter 模式：

     为了适应不同类的接口，常常需要修改各自的接口。但这样直接修改类的接口，会影响到其它已经使用该接口的代码。因此，通过 Adapter 模式定义一 个适应不同接口的接口类是解决此类问题的良好方式

   - Iterator 模式：

     对于保存数据的类来说，需要提供一种便于顺序访问类中的数据，同时又无需暴露类中数据的存储形式的方法。将保存数据的类称为容器，访问类中数据的算法封装在  Iterator 类中，称之为迭代器。这样，当定义新容器的同时，与之对应的 Iterator 类通过统一的接口来操作该容器中的数据。这样，在使用 Iterator 访问容器中数据时，不需要知道所处理的数据形式，从而迭代器就成为数据访问的方法与容器之间的一座桥梁

   - State 模式：

     在软件设计时，经常遇见根据不同的状态进行不同处理的问题，面对此类问题，通常的处理方法是采用多重if-then-else语句嵌套，或用switch-case语句进行处理。这种方式虽然简单可行，但会造成二个主要问题：一是实现过程中嵌套或分支较多，增加程序的复杂度;二是在后续修改、维护过程中，每当加入一个新的状态，就需要对原来的代码进行修改并重新编译，增加修改或维护的工作。State模式就是通过对不同状态的封装，以统一的方式处理上述问题

5. **面向对象的测试**

   - 面向对象测试概述
   - 面向对象的单元测试：
     - 确保属性的封装性约束
     - 派生类对基类成员函数的测试
     - 对抽象类的测试
   - 基于面向过程的面向对象单元测试

### 软件维护

1. **软件维护概述**
   - 软件维护的任务：
     - 在软件系统运行过程中发现测试阶段未能发现的、潜在的软件错误和缺陷
     - 随着软硬件环境的改变，与系统交互的外部系统的改变，网络通信技术的发展，系统数据或文件格式、存储方式、读取步骤的变迁，要求软件系统适应这些变化
     - 根据实际情况的发展，用户操作、流程发生改变，需要改进软件设计，增强软件功能，提高软件性能
     - 不断扩大软件系统的应用范围
   - 软件维护的特点：
     - 软件维护阶段是软件生命周期中，时间最长、工作量最大的活动
     - 软件维护虽立足于解决系统问题，改进系统功能和性能，但它不可避免地会引入新问题，直接影响软件质量
     - 软件维护实际上是一个简化的软件生命周期开发过程
     - 鉴于对上述的认识，软件维护也要按照软件工程开发过程和评审展开，对软件维护过程也运用工程化的原理、方法和技术进行软件维护工作
   - 软件维护的分类：
     - 完善性维护：扩充原有系统的功能，提高系统的性能，提高软件运行的效率，满足用户的实际需要而进行的维护活动
     - 纠错性维护：软件测试不可能找出一个软件系统中所有潜在的错误，所以当软件在特定 情况下运行时，这些潜伏的错误可能会暴露出来。对在测试阶段未能发现的，在软件投入使用后才逐渐暴露出来的错误的测试、诊断、定位、纠错以及验证、修改的回归测试过程
     - 适应性维护：计算机的软、硬件环境，数据环境在不断的变化，使运行的软件能适应运行环境或者数据的变动而修改软件的过程称为适宜性维护
     - 预防性维护：为了进一步改善软件的可靠性和易维护性，或者为预见的将来软件运行和维护打下更好的基础而对软件进行修改。
2. **软件维护过程**
   - 软件维护方式：
     - 非结构化维护
     - 结构化维护
   - 软件维护管理的基本内容：
     - 维护的组织结构
     - 提交软件维护申请报告
     - 指定维护工作流
     - 软件维护的组织管理
     - 维护成本：
       - 非技术因素：
         - 开发经验
         - 人员稳定性
         - 应用时间
         - 外部支撑环境
         - 用户需求变化
       - 技术因素：
         - 软件复杂程度
         - 软件维护员的能力
         - 软件配置管理能力
         - 软件编程规范
       - 两种估算模型 :book:（P285）
   - 维护中存在的问题：
     - 可维护性问题：
       - 代码没有注释
       - 缺乏软件配置
       - 开发人员的流动性
       - 缺少软件维护理念
       - 缺乏对软件维护工作的认识
     - 软件维护副作用：
       - 修改代码的副作用：在修改源代码时，可能引起的错误
       - 修改数据的副作用：在修改数据结构时，有可能造成软件设计与数据结构不匹配，因而导致 软件出错
       - 修改文档的副作用：对软件的数据流、软件结构、模块逻辑等进行修改时，必须对相关技术 文档进行相应修改。但修改文档过程会产生新的错误，导致文档与程序功能 不匹配，缺省条件改变等错误
   - 维护活动记录
3. **软件的可维护性**
   - 可维护性因素：
     - 可理解性
     - 可测试性
     - 可修改性
     - 可移植性
     - 可重用性
   - 提高软件的可维护性：
     - 软件文档配置：
       - 用户文档
       - 系统文档
       - 历史文档
     - 使用能提高维护效率的开发技术和工具：
       - 模块化设计
       - 结构化程序设计
       - 面向对象程序设计
       - 伪代码设计规范
     - 可维护性复审：
       - 开发各阶段的可维护性因素
       - 软件维护不是面对源程序代码，而是整个软件文档配置
       - 编程的风格和代码规范，对软件维护起着重要作用

### 软件项目管理

1. **软件项目管理概述**

   - 项目的定义：

     目是一个特殊的将被完成的有限任务，它是在一定时间内，满足一系列特定目标的多项相关工作的总称

   - 软件项目管理目标：

     - 如期完成项目
     - 项目成本控制在计划之内
     - 妥善处理用户的需求变动
     - 保证项目质量
     - 保持对项目进度的跟踪与控制

2. **软件项目规模度量**

   - 直接度量和间接度量：
     - 直接度量是指通过对软件产品的简单属性直接计算而得到结果的过程。简单属性是指代码行数、操作数和运算符个数、接口个数等能直接计数的特征，它反映的是软件产品内部特征
     - 间接度量是指通过对软件产品的简单属性、要素的各项特征、准则的经验值间接计算而得到结果的过程。如软件质量评价、软件复杂性测量等
   - 代码行技术（直接度量）
   - 功能点计算（间接度量）
   - 代码行与功能点间的转换

3. **软件项目估算**

   - 代码行和功能点的其他估算模型
   - 专家估算模型
   - Putnam 模型
   - COCOMO 模型

4. **项目进度管理**

   - 项目进度控制
   - 甘特图
   - 网络工程图

5. **软件能力成熟度模型（SW-CMM 或 CMM）**

   - 软件能力成熟度模型等级：
     - 初始级
     - 可重复级
     - 已定义级
     - 已管理级
     - 优化级

### 测试题

1. **为高质量地开发软件项目，在软件结构设计时，必须遵循（A）原则。**

   A. 信息隐蔽	B. 质量控制	C. 程序优化	D. 数据共享

2. **需求规格说明书的作用不包括（C）。**

   A. 软件验收的依据	B. 用户与开发人员对软件要做什么的共同理解

   C. 软件可行性研究的依据	D. 软件设计的依据

3. **为了使软件具有清晰结构和良好的风格，下面关于程序设计风格的叙述不可取的有（A）。**

   A. 尽量不要进行浮点数的相等比较	B. 应当有适量的注释

   C. 尽可能对代码优化	D. 使用有意义的标识符

4. **详细设计与概要设计衔接的图形工具是（D）。**

   A. DFD图	B. 程序图	C. PAD图	D. SC图

5. **一般说来，投入运行的软件系统中有错误（A）。**

   A. 不是不可以理解的	B. 是不能容忍的	C. 是要求退货的理由	D. 是必然的

6. **一个局部数据存储当它作为（D）时就把它画出来。**

   A. 某些加工的数据接口	B. 某个加工的特定输入

   C. 某个加工的特定输出	D. 某些加工的数据接口或某个加工的特定输入 / 输出

7. **对于软件需求规格说明（SRS）完整性的正确的理解应该是（D）。**

   A. 能通过技术手段或成本、效益等验证系统符合需求

   B. SRS 的描述内容要用确定的唯一术语来定义

   C. 保证用户和开发人员都能正确地理解系统需求

   D. 对于需求信息及建模中的术语，在数据字典中必定能找到对应的信息

8. **如下关于白盒测试错误的论述是（A）。**

   A. 白盒测试更多地关注系统的全局而非局部	B. 白盒测试需要程序员和测试人员共同完

   C. 白盒则是需要详细设计文档作为测试配置

   D. 白盒测试需要保证每一条独立路径都至少执行一次

9. **如下有关软件测试论述正确的是（D）。**

   A. 集成测试是验证系统编码的	B. 单元测试是验证软件分析的

   C. 系统测试是验证系统设计的	D. 测试 V 模型表达了测试对应软件各阶段的验证关系

10. **对 UML 用例图的不正确说明是（B）。**

    A. 用例图是从系统外部描述系统功能及功能之间关系的

    B. 用例图可表达功能的实现协议和逻辑过程

    C. 用例图的参与者是指使用系统相关功能的一个角色

    D. 用例图的扩展关系，表示对基本功能扩展后可选的功能

11. **对 UML 类图不正确地解释是（C）。**？

    A. 类图可表达系统的静态结构

    B. 类图中的属性和方法表达了类的内部结构

    C. 类图中的关联表达了类之间相互访问的消息

    D. 类图中的继承关系表达类之间一般和特殊的关系

12. **经济可行性研究的主要内容包括（D）。**

    A. 开发过程	B. 开发工具	C. 风险分析	D. 效益分析

13. **本是无关的任务，由于需要在同一过程中运行而将其聚集在一个模块内的内聚被称为（A）。**

    A. 时间内聚	B. 逻辑内聚	C. 过程内聚	D. 通讯内聚

14. **软件中遗留的错误数量与已经发现的错误数量成（B）。**

    A. 反比	B. 正比	C. 相等	D. 没关系

15. **可以对象之间消息传递是（D）。**

    A. 功能模型	B. 用例模型	C. 数据模型	D. 交互模型

16. **为使程序中数据说明更易于理解和维护，必须遵循以下原则（ABC）。**

    A. 数据说明的次序应当规范化	B. 一个语句说明多个变量时，各变量名按字母顺序排列

    C. 对于复杂的数据结构，要加注释，说明在程序实现时的特点

    D. 定义变量名应按字母顺序排列

17. **画分层 DFD 图的基本原则有（ABC）。**

    A. 数据守恒原则	B. 数据流封闭原则	C. 父子图平衡原则	D. 分解的可靠性原则

18. **常见的软件开发方法有（ABC）。**

    A. 结构化开发方法	B. 面向数据结构的开发方法	C. 面向对象开发方法	D. 增量方法

19. **在开发软件的实践中，人们通常采用网状结构，而不采用树状结构。（F）**？

20. **在网状结构中任何两个模块都是平等的，没有从属关系，所以在软件开发过程中常常被使用。（F）**？

21. **判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖。（T）**

22. **若前一模块的输出作为后一模块的输入，将其合并为一个模块叫做过程内聚。（F）**？

23. **类的关联是不能被继承的。（F）**？

24. **软件算法设计的可读性和可理解性比算法的效率更重要。（T）**

25. **通常类名采用名词或名词短语，如果采用动词，则描述的是类的关联类。（T）**？

26. **结构化设计属于面向数据流的设计方法。（F）**

27. **单元测试一般以（白盒）测试为主，（黑盒）测试为辅。**

28. **类聚合关系可以表示类的对象实例之间（整体和部分）关系。**？

