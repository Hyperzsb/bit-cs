# 第2章 - 进程管理

### 进程的概念

1. **程序的顺序执行**

   也称程序的串行执行：机器只执行一个程序，执行程序的一个操作，只有在前一个操作完成后，才进行下一个操作

   特点：

   - 程序运行环境的封闭性：程序在运行时独占全机资源，这些资源的状态只能由这个运行的程序决定和改变，不受外界因素影响
   - 程序结果的可再现性：程序执行时，只要初始条件相同，程序执行结果与其执行速度无关，其最终结果不变
   - 实现简单，但资源利用率低

2. **程序的并行执行**

   计算机同时运行多个程序，即多个程序在 CPU 上交叉运行

   特点：

   - 增强了计算机系统的处理能力，提高了资源利用率
   - 失去了程序的封闭性和可再现性：并发程序执行的结果与其执行的相对速度有关，是不确定的
   - 并行执行的程序间产生了相互制约关系：间接制约关系和直接制约关系
   - 程序与 CPU 执行的活动之间不再一一对应

3. **进程的概念**

   进程（Process），又叫做任务（Task）：

   - 是程序的一次执行过程
   - 是程序在一个数据集合上顺序执行时发生的活动。是系统进行资源分配和调度的一个独立单位

4. **进程的特点与同程序的关系**

   - 进程是程序的一次执行过程，具有动态性：程序是完成某个特定功能的指令的有序序列，是一个静态的概念。程序可以作为一种软件资源长期保存。进程把程序作为它的运行实体，没有程序，也就没有进程。进程是程序的一次执行过程，它是临时的，有生命周期的，由创建而产生，完成任务后被撤销
   - 进程是系统进行资源分配和调度的一个独立单位，具有独立性
   - 一个进程可以与其他进程并发执行，具有并发性
   - 进程具有结构性：从结构上看，进程是由程序、数据和进程控制块三部分组成

### 进程的描述

1. **进程控制块**

   为了描述进程的运行变化情况，操作系统为每个进程定义了一个数据结构，叫进程控制块（Process Control Block, PCB），也叫进程描述符（Process Descriptor, PD），它是进程存在的唯一标识。它包含了进程的描述信息和管理控制信息，是进程动态特性的集中体现

   PCB 应包含如下一些基本信息：

   - 进程表示数：系统中的每个进程都有一个唯一的标识，通常是一个整数
   - 进程的状态以及调度和存储器管理信息：进程目前状态、进程优先级、程序在主存的入口地址、在外存的地址等
   - 进程使用的资源信息：分配给进程的 I/O 设备、正在执行的 I/O 请求信息、当前进程正打开的文件等
   - CPU 现场保护区：程序计数器（PC）、程序状态字（PSW）、通用寄存器及堆栈指针等
   - 记账信息：CPU 时间量、账号等
   - 进程之间的家族关系
   - 进程的链接指针：为了管理的需要，系统在 PCB 中设置一个链接指针，用于将相同状态的进程链接在一起

2. **进程的状态**

   - 创建态：指进程刚刚被创建，还没有正式提交给处理机调度程序对其进行管理时的状态
   - 终止态：指进程不再受处理机调度管理，其原因是它可能已经正常完成或故障中断
   - 就绪态：指进程已经获得了除 CPU 之外的全部资源，等待系统分配 CPU，一旦获得 CPU，进程就可以变为运行态
   - 运行态：正在 CPU 上执行的进程所处的状态为运行态
   - 阻塞态：当一个进程因等待某个事件发生，如等待 I/O 完成或等待接收一个消息，而不能运行时，处于阻塞态，处于阻塞态的进程在逻辑上是不能运行的，即使 CPU 空闲，它也不能占用 CPU

   一个进程在执行过程中可能要多次反复地经历就绪、阻塞和运行三个基本状态的转换

3. **进程的组织**

   - 线性表：把所有进程的 PCB 组成一个数组，系统通过数组下标访问每一个 PCB。优点是简单，节省存储空间；缺点是系统开销大
   - 链接表：为管理方便，通常把处于同一状态的进程 PCB 按照一定方式链接成一个队列，这样就形成了就绪队列和阻塞队列。处于就绪态的进程可按照进程调度的某种策略排成多个就绪队列；处于阻塞态的进程又可以根据阻塞的原因不同排成多个阻塞队列

> 为确保系统的性能，大多数系统都限制创建进程的数量

### 进程的控制

进程的控制是指系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间转换的一系列有效管理。这些程序段是系统内核实现的。进程控制程序是不允许被中断的程序，或叫其执行过程不可分割的原语实现的

1. **创建原语**

   创建进程的时机：

   - 批处理系统中，通过磁盘或磁带向操作系统提交一个批作业控制流时，操作系统除准备接纳一个新作业外，还要为每个作业创建一个用户进程
   - 一个分时系统，用户在终端上登录时，系统为每个用户创建一个终端进程
   - 已存在的进程可以创建一个或多个子进程，完成指定的用户任务

   创建原语的功能：进程控制块是进程存在的唯一标识，所以创建一个进程的主要任务就是为其建立一个控制块。创建原语的功能是扫描系统的 PCB 集合表，找到一个空闲的 PCB，并获得该 PCB 的内部名称，作为进程的标识。若其实体（程序和数据等）不在主存，也应为其分配主存，并掉入主存，然后把调用者提供的参数：进程名、进程优先级、实体所在的主存的起始地址、所需的资源清单、记账信息及进程家族关系等，填入 PCB 结构中，并将新创建进程的状态置为就绪态，再插入就绪队列中

2. **撤销原语**

   撤销进程的时机：如果一个进程已完成指定任务或由于故障不能继续运行时，应被撤离系统而消亡。所谓撤销，是指撤销进程存在的标识，即进程控制块。一般来说，在进程家族的树形结构中，当一个进程被撤销时，还要将其创建的各个子孙进程也全部撤销

   撤销原语的功能：在 PCB 集合表中寻找所要撤销的进程。若找到，再检查该进程是否有子进程：若有，则先将其子进程所占用资源收回给系统，并撤销各子进程对应的进程控制块。之后，把该进程占用的系统资源归还系统，最后将它的 PCB 撤销

3. **阻塞原语**

   阻塞进程的时机：处于运行态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘的数据传输完成或等待其他进程发送一个信息等。当被等待的事件还没有发生时，进程自己执行阻塞原语，使自己由运行态变为阻塞态

   阻塞原语的功能：处于运行态的进程中断 CPU，将其运行现场保存在其 PCB 的 CPU 现场保护区；将其状态置为阻塞态，并插入相应事件的等待队列中；最后转处理机调度

4. **唤醒原语**

   唤醒进程的时机：当某进程期待的事件已经到来

   唤醒原语的功能：

   - 当进程期待的事件是等待 I/O 完成时：在 I/O 完成后，由硬件设备提出中断请求，CPU 响应中断，暂停当前进程的执行，转去进行中断处理。在中断处理中，检查有无等待该 I/O 完成的进程：若有，则将等待者唤醒，将其由阻塞态置为就绪态，从等待队列抽出，插入就绪队列，然后结束中断处理。之后，或者返回被中断进程继续执行，或者转处理机调度，重选一个进程投入运行
   - 若进程期待的事件是等待某进程发一个信息：当信息发送给该等待进程时，由发送进程把该等待者唤醒，并将其由阻塞态置为就绪态，插入就绪队列即可

5. **挂起原语**

   在实时系统中，根据实时现场的需要，通常引入挂起原语和解挂（激活原语）。

   常用的挂起方式：

   - 挂起当前运行进程自己
   - 挂起指定进程
   - 挂起指定进程及其子孙进程

   一个进程一旦被挂起，它或者由运行变为静止就绪，或者由活动就绪变为静止就绪，或者由活动阻塞变为静止阻塞

6. **解挂（激活）原语**

### 处理机的调度

1. **处理机调度的级别**

   - 处理机的高级调度，又称为作业调度：在多道批处理系统中，作业调度时非常必要的。为充分利用系统资源，通常将 I/O 量大与 CPU 量大的作业结合在一起进行调度。在分时系统中，通常没有作业调度，其目的是为了对各用户命令的及时响应，使用户进程得到快速运行
   - 处理机的低级调度，又称为进程调度：作业调度和进程调度的主要区别在于调度程序的频度。作业调度只有在一个作业退出系统时才需要被调用执行。进程调度的目的是使一些进程并发执行，以最大化 CPU 的利用率。因此，进程调度是比较频繁的
   - 处理机的交换调度，又称中级调度或换入换出：是指为了充分利用系统资源和更快响应各进程，将处于主存就绪或主存阻塞等不具备运行条件的进程换出到外存交换区；将处于外存就绪具备运行条件的进程换入主存，以便运行它

2. **进程机调度的功能**

   > 进程调度也称为处理机的低级调度，或直接称为处理机调度

   - 管理系统中各进程的执行情况：处理机调度程序就是通过 PCB 变化来准确掌握系统中所有进程的执行情况和状态特征的
   - 选择进程真正占有 CPU：这是处理机调度的实质
   - 进行进程上下文的切换：进程的上下文是指操作系统为运行进程设置的相应的运行环境和进程的物理实体，由三部分组成：
     - 用户级上下文：进程的实体中的程序和数据
     - 寄存器级：CPU 的现场信息
     - 系统级上下文：PCB、进程运行时的系统环境，包括进程状态和存储器的管理信息

3. **进程调度的方式**

   - 非抢先（非剥夺）方式：调度程序一旦把 CPU 分配给某一进程后便让它一直运行下去，直到进程完成或发生某事件（发生错误、提出 I/O 请求等）而不能运行时，才将 CPU 分给其他进程。当一个紧急任务需要及时处理时，该调度方法无法满足，从而影响系统的实时性。通常用在批处理系统中，简单、系统开销小
   - 抢先（剥夺）方式：当一个进程正在执行时，系统可以基于某种策略剥夺 CPU 给其他进程。这种调度方式更多用在分时系统和实时系统，以及现代的多任务操作系统中，以便充分保证进程的并发性和及时响应

4. **进程调度的时机**

   - 现行进程完成执行或由于某种错误而中止运行
   - 正在执行的进程提出 I/O 请求，等待 I/O 完成
   - 分时系统中，按照时间片轮转，分给进程的时间片用完
   - 基于优先级调度，有更高优先级进程变为就绪
   - 进程执行了某种原语操作，如阻塞原语或唤醒原语时，都可能引起进程调度

5. **处理机调度算法**

   >  以下三种算法常常用于批处理系统中的作业调度

   - 先来先服务调度法（First Come First Serve, FCFS）：系统维护一个队列，按照进程到达就绪队列的先后次序顺序调度运行。优点是节省机器时间、运行效率高；缺点是容易被大作业进程垄断，使得平均等待时间延长

   - 最短作业的进程优先调度法（Short Job First, SJF）：要求每个作业的进程提供所需的运行时间，每次调度时总是选取运行时间最短的进程运行。优点是对于运行时间短的进程有利，进程的平均等待和周转时间最佳，容易实现；缺点是可能使得长进程没有机会运行，这种现象称为饿死

   - 响应比高者优先调度法（High Response Next, HRN）：该算法兼顾了运行时间短和等待时间长的作业。响应比 

     $$R_p = (作业等待时间 + 作业估计运行时间) / 作业估计运行时间 = 1 + 作业等待时间 / 作业估计运行时间$$

     但是由于每当进行作业调度时，系统需要花费大量时间计算各个作业的响应比，系统开销较大

   > 以下三种算法常用于分时系统

   - 优先级调度法（Priority Scheduling）：这是最常用的一种进程调度方法。系统总是将 CPU 分配给就绪队列中优先级最高的进程。确定优先级的方法分为两种：
     - 静态优先级法：静态优先级是系统创建时确定的，它依据进程的类型是用户进程还是系统进程。通常赋予系统进程较高优先级。对于用户进程，还要根据申请资源情况决定，申请资源少的赋予较高优先级。一旦进程的优先级确定了，在整个运行过程中将保持不变。优点是简单；缺点是不能动态反映进程特点，与 SJF 一样，使得低优先级的长进程没有机会运行
     - 动态优先级法：进程在开始创建时，根据某种原则确定一个优先级后，随着进程执行时间的变化，其优先级不断地进行动态调整。缺点是需要一定的系统开销
   - 轮转法（Round Robin, RR）：通常用在分时系统中，它轮流地调度系统中所有就绪进程。使用一个定时时钟，使之定时地发出中断，时钟中断处理程序在设置新的时钟常量后，即转入处理机调度。时间片长短的确定遵循这样的原则：既要保证系统各个用户进程及时地得到响应，又不要由于时间片太短而增加调度的开销，降低系统的效率
   - 多级反馈队列轮转法（Multi-level Feedback Queue, MFQ）：系统设置多个就绪队列，且进程在其声明周期内可能在多个队列中存在，几个队列可以采用前后台运行。前台队列采用 RR 进行调度，后台采用 FCFS 进行调度。前台进程优先级都高于后台进程。前台的各种队列的时间片也不一样，高优先级队列进程的时间片较短，低优先级队列进程的时间片较长。通常刚创建的进程和因请求 I/O 未用完时间片的进程排在最高优先级队列。在这个队列中各进程轮流运行2～3个时间片，未完成的进程排到下一个较低优先级队列

   > 以下两种方法用于实时操作系统

   - 时钟驱动法（Clock-Driven）：各任务的调度安排通常是在系统开始运行前就确定的
   - 加权轮转法（Weighted Round-Robin）：不同的进程可以给不同的权值，权值就是分配给它的一小部分处理器时间。每次轮转时，各个进程获得处理机的时间就是它具有的权值长度。该算法广泛应用在高速开关网的实时控制中

### 线程的引入

1. **线程的概念**

   > 在引入线程的操作系统中，把线程作为处理机调度的基本对象，而把进程只作为除 CPU 外的系统资源的分配对象

   进程在逻辑上表示操作系统必须做的一个任务，线程表示完成该任务的许多可能的子任务。线程是进程中的一个可执行实体，是被操作系统调度的一个独立单位。一个进程可以有多个线程，多线程共享该进程拥有的所有资源

   一个线程也由一个线程控制块描述，包括：

   - 有一个唯一的标识符
   - 有表示处理机状态和运行现场的一组寄存器，用于保护 CPU 的现场信息
   - 有两个堆栈，分别用于用户态和核心态调用时进行参数传递
   - 有一个独立的程序计数器，或叫做一个私有的存储区
   - 关联的进程和线程指针

2. **线程与进程的比较**

   - 拥有的资源：一个进程拥有一个独立的存储空间、打开的文件以及至少一个线程；进程中的其他线程时通过调用线程创建原语显式创建的；进程中只要还有一个线程在执行，这个进程就不会终止
   - 调度：进程调度时，进行进程上下文的切换需要较大的系统时间和空间的开销；而采用线程调度时，由于同一进程内的线程共享进程的资源，其上下文切换只把线程仅有的一小部分资源交换即可，从而提高了系统的效率
   - 并发性：系统不仅进程之间可以并发执行，而且同一进程内的多线程也可以并发执行
   - 安全性：由于同一进程的多线程共享进程的所有资源，一个错误的线程可以任意改变另一个线程使用的数据而导致错误的发生，而使用多进程则不会产生这一问题。从保护的角度看，使用多进程比多线程在安全性上可能更有效

3. **系统对线程的支持**

   - 用户级线程：是指有关线程的所有管理工作都由用户程序通过调用用户态运行的线程库来完成，系统内核并不知道线程的存在。任何一个用户级线程的阻塞，都将引起整个进程的阻塞。将这种模型称为多对一模型
   - 核心级线程：是指有关线程的管理工作都由系统内核完成。用户应用程序是通过调用线程的 API 来管理线程的。由于内核支持线程，任何一个线程的阻塞，一般不影响同一进程的其他线程的执行。称这种模型为一对一模型。系统通常对应用创建的线程数量有一定限制
   - 两级组合：有些系统既支持用户级，也支持核心级线程。多个用户级的线程可以对应等量或少量的核心级线程。当一个线程阻塞时，核心可调度同一进程或不同进程的另一个线程执行，使得线程在宏观和微观上都能很好地并行。称这种模型为多对多模型