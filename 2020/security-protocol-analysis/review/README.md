# 安全协议复习提纲

### 安全协议引论

1. **协议**

   计算机通信领域的协议是指协议中两个或两个以上的参与者为了达到特定的目的而采用的一系列步骤，包含了以下几层含义：

   - 协议规定了一系列有序执行的步骤，必须依次执行
   - 协议中有两个或者两个以上的参与者。一个参与者是不能构成协议的
   - 协议都有明确的目的，即需要完成什么目标，防范什么风险等

2. **密码协议**

   - 概念：

     密码协议也称为安全协议。密码协议需要使用一些基本的 密码算法作为构造协议的基本模块，并满足一定的安全需求。有一些密码协议并没有使用密码算法（线性秘密分享、安全多方计算协议等）但是还是习惯将这些协议都归入密码协议的范畴。

   - 特点：

     密码协议的设计和一般协议相比除了有正确性和执行效率的要求外，还有以下一些特殊要求：

     - 安全需求：
       - 加密：保证密码协议执行过程中所涉及的敏感数据不能为非授权者所知
       - 认证：保证协议参与者的合法身份
       - 不可抵赖性：保证协议执行过程是可以稽查的，对于有仲裁者（可信第三方）参与的密码协议是很关键的
     - 鲁棒性：
       - 并不是所有密码参与者都是按照协议的要求来执行协议的，其中可能有恶意参与者
       - 要求密码协议在有恶意参与者的情况下能部分地正确执行，同时严格保护其他诚实参与者所持有的秘密信息

   - 分类：

     通常根据协议对可信第三方的依赖程度可以将密码协议分为：

     - 仲裁协议：仲裁者就是可信第三方，协议需要可信第三方的帮助才能正确执行。仲裁协议的问题是现实的计算机网络中很难找到一个协议参与者都信任的仲裁者，且仲裁者容易成为易受攻击之处
     - 裁决协议：裁决者也是可信第三方，但是裁决者并不直接参与协议的执行。裁决者只是在有争议的时候才参与协议的执行。这样协议对可信第三方的依赖程度降低了
     - 自动执行协议：最理想的协议，协议本身体现了公平性，不需要可信第三方的参与。当某个参与者实施欺骗行为时能够被其他参与者发觉，从而终止协议或者将欺骗者排除

3. **密码协议模型**

   - 概念：

     密码协议的设计和分析都必须在一定的条件和假设下进行，例如协议参与者的个数、协议参与者的诚实程度、协议参与者的网络连接情况等。所有这些条件和假设构成了密码协议的模型（Model），密码协议的模型描述了密码协议的运行环境。通常从三个方面来描述密码协议模型：协议参与者的类型、参与者的网络连接情况和协议攻击者的能力

   - 协议参与者角色类型：

     - 协议参与者：参与者按照协议的要求参与协议的执行，向协议提供输入，从协议中获得输出
     - 协议攻击者：除了协议本身需要的参与者之外，还会有一些“参与者”通过窃听或者篡改报文等方法“主动”参与到协议的执行过程，这类参与者常常被称为“协议攻击者”。密码协议中始终要考虑攻击者的存在。攻击者和参与者之间没有严格的界限，攻击者也可能是参与者
     - 可信第三方（TTP）：是参与者都信任的一个主体或者一个组织。如果没有可信第三方的存在，一些基础的密码协议（公钥分发）是无法执行的。可信第三方的存在还可以简化很多密码协议的设计，提高协议的效率
     - 仲裁者：可以使协议执行过程中发生的争端以公平合理的方式得到处理

   - 协议参与者网络连接情况：

     参与密码协议的参与者都连接在一个网络中，这个网络可能是同步的网络，也可能是非同步的网络。在一个同步网络中，所有协议参与者都有一个公共的、全局的时钟。所有的信息在某一个时钟周期内传送，所有的协议参与者能在下一个时钟周期得到传送给自己的信息；在非同步网络中，不存在这样一个全局的时钟，信息从一个参与者处传送出去，到接收者接收到信息要经历不确定个时钟周期，且收到信息的顺序很有可能不是发送信息的顺序。

     可以将同步和不同步的这种性质看作是攻击者的能力。

     由于非同步网络条件下设计密码协议比较复杂，所以大部分密码协议的研究都在同步网络条件下

   - 协议参与者诚实程度：

     依据参与者遵从协议的诚实程度可以将参与者分为：

     - 诚实参与者：参与者按照协议的要求参与协议的执行，向协议提供输入，从协议中获得输出
     - 半诚实参与者：这类参与者按照协议的要求执行，只是窃听或获取其他参与者在协议进行中的所有输入。也称这种参与者为被动攻击者或窃听者
     - 恶意攻击者：攻击者不仅窃听或获取不诚实参与者在协议进行中的所有输入，还要控制参与者按照自己设计的方式参与协议。恶意攻击者以破坏协议正确执行或者获取其他参与者的隐私输入为目的。这种攻击者称为主动攻击者或 Byzantine 攻击者

   - 协议攻击者能力：

     可以将协议的攻击者看作是所有协议参与者之外的一个实体，它可以控制若干个协议参与者，也可以将攻击者看作是一个或多个参与者。通常从攻击者的计算能力，对通信网络的控制能力以及是否主动攻击等方面来刻画攻击者能力：

     - 拥有无限计算能力的攻击者
     - 只有概率多项式时间计算能力的攻击者

     在无限计算能力攻击者存在的情况下安全的协议一般称为信息论安全的，对于多项式时间计算能力的攻击者安全的协议一般称为密码学安全的

     根据攻击者对于通信信道的控制可以分为3种，相应地对应三种不同级别的安全等级：

     - 安全信道：攻击者对于通信信道没有任何控制能力。诚实协议参与者之间的通信既不会被攻击者窃听，也不会被攻击者篡改
     - 非安全信道（认证信道）：攻击者可以窃听任何协议参与者之间的通信，但是不能篡改通信的内容
     - 未认证信道：攻击者对于通信网络有着完全的控制权，不仅可以窃听所有协议参与者之间的通信，还可以任意篡改通信的内容

4. **Dolev-Yao 模型**

   - 将认证协议本身与认证协议所具体采用的密码系统分开，在假定密码系统是“完美”的基础上讨论认证协议本身的正确性、安全性、冗余性等课题
   - 为攻击者建立了模型。认为不能低估攻击者的知识和能力，攻击者可控制整个通信网络，具有以下能力：
     - 转发消息到其指定接收者处
     - 延迟消息的送达
     - 将消息篡改后转发
     - 将消息与以前接收的消息合并
     - 改变部分或全部消息的去处
     - 重放消息

5. **密码协议的性质及实现**

   - 认证性（关键性质）：

     - 概念：认证的基本思想是通过验证称谓者（人或事）的一个或多个参数的真实性和有效性，来达到验证称谓者是否名副其实的目的

     - 实现：

       - 声称者使用仅为其与验证者知道的密钥封装消息，如果验证者能够成功地解密消息或验证封装是正确的

       - 声称者使用私钥对消息签名，验证者使用声称者的公钥验证签名，如正确，证毕

       - 声称者通过可信第三方来证明自己

   - 不可否认性：

     - 概念：又称拒绝否认性、抗抵赖性，指网络通信双方在信息交互过程中，确信参与者本身和所提供的信息真实同一性，即所有参与者不可否认或抵赖本人的真实身份，以及提供信息的原样性和完成的操作与承诺
     - 实现：
       - 通过通信主体提供对方参与协议交换的证据来保证其合法利益不受侵害
       - 收集证据，以便事后能够向可信仲裁证明对方主体 的确发送或接收了消息

   - 机密性：

     - 概念：是不将有用信息泄漏给非授权用户的特性
     - 实现：对消息明文加密

   - 完整性：

     - 概念：是指信息在传输、交换、存储和处理过程中，保持信息不被破坏或修改、不丢失和信息未经授权不能改变的特性，也是最基本的安全特征
     - 实现：封装和签名。即用加密的方法或者 Hash 函数产生一个明文的摘要附在传送的消息上，作为验证消息完整性的依据，称为完整性校验值 (ICV)

6. **密码协议设计过程**

   整个密码协议设计分析的过程是一个迭代过程，主要包括需求分析、需求定义、协议具体步骤设计、协议正确性分析、协议安全性分析这5个阶段

   - 需求分析：需要明确密码协议工作于什么样的协议模型中，即参与者角色分类、参与者诚实情况、网络连接情况等。明确协议的目的，即通过协议的执行参与者之间能够达成的目标。明确协议的安全需求，如加密、认证等需求
   - 需求定义：将需求分析阶段所明确的协议目的和安全需求以合适的语言描述出来。描述需求定义的语言可以是自然语言，也可以是形式化语言。使用自然语言描述需求定义比较简单，但是不利于严谨的协议分析；使用形式化语言来描述需求定义比较抽象，但是可以为协议的严谨分析打下良好的基础
   - 协议具体步骤设计：需要描述协议参与者之间如何进行通信以及具体的每一条通信消息的格式。在这个阶段协议参与者参与协议的每一个行为都需要清晰地描述
   - 协议正确性分析：即协议执行完毕之后是否达成了协议的目标。正确性分析主要关注协议的功能是否满足以及在协议执行过程中，针对可能出现的各种情况协议是否都有充分的考虑
   - 协议安全性分析：主要分析协议的执行过程是否能满足相应的安全需求。 分析过程可以使用自然语言的推理方法，也可以使用形式化的推理 方法，使用自然语言的推理的安全性分析极其容易出现逻辑不严谨和误证；使用形式化推理方法能较好地克服这些问题

7. **密码协议设计准则**

   - 消息独立完整性原则：

     一条消息的解释应完全由其内容来决定，而不必借助于上下文来推断

   - 消息前提准确原则：

     与消息的执行相关的先决前提条件应当明确指出，并且其正确性与合理性能够得到验证，由此可判断出此消息是否应当接收

   - 主体身份标识原则：

     主体标识重要时在消息中明确附上主体名称

   - 随机数的使用原则：

     在协议中使用随机数时，应明确其所起 作用和属性，它的目的是提供消息的新鲜性

   - 时戳的使用原则：

     使用时戳时，要考虑各个机器的时钟与当地标准时间的差异，这种差异不能影响到协议执行有效性
   
8. **思考题**

  - 在日常生活中找到一个常用的协议，并试着描述这个协议
  - 三个人切苹果，如何设计协议以保证能切得均匀公平
  - 电子支付协议极大地方便了人们的生活，促进了网上交易。根据你自己的生活经验，描述电子支付协议应该满足的安全需求

### 密码学概述

1. **明文、密文、密钥**

2. **加密变换、解密变换**

3. **发送者、接收者、分析者**

4. **攻击类型**

   - 唯密文攻击
   - 已知明文攻击
   - 选择明文攻击
   - 选择密文攻击

5. **Kerckhoffs 准则**

   在评估一个密码系统安全性时，应该总是假设我们的敌人了解实际使用的各种方法

   在现代密码算法中就是指攻击者知道密码算法的所有执行细节，算法的安全不应该依赖于对算法的保密，依赖于密钥的保密

6. **古典密码、对称密码体制（私钥密码体制）、非对称密码体制（公钥密码体制）**

   - 古典密码：

     安全依赖于保密具体的密码算法

   - 对称密码：

     安全依赖于保密密钥。算法简单，加解密速度快；不便于密钥管理

   - 非对称密码：

     安全依赖于保密部分密钥。不存在密钥管理问题，还可用于消息认证；算法一般比较复杂，加解密速度慢

     公钥密码计算量大，不适合加密大量数据，一般采用用公钥密码加密私钥密码的密钥进行密钥的传输，再使用私钥密码对大量数据进行加密后传输

7. **现代密码学解决的基本安全问题**
   - 机密问题
   - 数据真实完整问题
   - 认证问题
   - 不可否认问题

8. **现代密码学的基本概念和技术**

   - 单向函数、陷门单项函数

   - 加密：

     - 明文消息空间 $M$：某个字母表集
     - 密文消息空间 $C$：可能的密文消息集

     - 加 / 解密密钥空间 $K$：可能的加 / 解密密 钥集

     - 加 / 解密函数 $E_{e \in K}(m \in M)$ / $D_{d \in K}(c \in C)$：一个从 $M$ 到 $C$ / $C$ 到 $M$ 的有效变换

   - 破译：

     一个加密方案可以被破译是指，第三方在没有事先得到密钥对 $(e, d)$ 的情况下，可以在适当的时间里系统的从密文恢复出相对应的明文

   - 私钥加密：

     每一个相关联的密钥对 $(e, d)$，如果知道了 $e$ 在计算上很容易确定 $d$，知道了 $d$ 在计算上很容易确定 $e$，就称其为私钥加密方案。私钥加密需要一条安全信道来建立密钥对

   - 分组密码

   - 流密码

   - 公钥加密

   - 可逆公钥加密算法：

     对于满足 $D_d(E_e(m))=E_e(D_d(m))=m$ 和 $M=C$ 的公钥加密算法，称为可逆公钥密码算法

9. **经典加密算法**

   - DES 算法：
     - 初始置换（$IP$）
     - 子密钥生成
     - 16轮迭代：
       - 扩展置换
       - S 盒代换
       - P 盒置换
     - 逆初始置换（$IP^{-1}$）
   - RSA 算法：
     - 密钥生成：
       - 随机选择两个不相等的素数 $p$ 和 $q$
       - 计算 $n=p \times q$ 和 $\phi(n)=(p-1)(q-1)$
       - 随机选择一个整数 $e$ 使得 $gcd(e,\phi(n))=1$（任意大于 $p$ 和 $q$ 的素数都可以）
       - 计算 $d=e^{-1} \pmod {\phi(n)}$（若知道 $e$ 和 $\phi(n)$ 则很容易计算出 $d$）
       - 公钥为 $(n,e)$，私钥为 $d$
     - 加密：加密明文 $m$ 为 $c=m^e \pmod n$
     - 解密：解密密文 $e$ 为 $m=c^d \pmod n$
   - ElGamal 算法：
     - 密钥生成：
       - 随机选择素数 $p$
       - 计算 $F^*_p$ 的一个随机乘法生成元 $g$
       - 随机选择 $x(1 \lt x \lt p-2)$，计算 $y=g^x \pmod p$
       - 公钥为 $(y,g,p)$，私钥为 $x$
     - 加密：选择随机数 $k(1 \lt k \lt p-2)$，加密明文 $m$ 得到密文对 $(c_1=g^k \pmod p,c_2=my^k \pmod p)$
     - 解密：解密密文对 $c_2c_1^{-x} \pmod p=my^k(g^k)^{-x} \pmod p=m$
     - 特点：通过选择不同的随机数 $k$，即使是相同的加密密钥，也可以将相同的明文加密成不同的密文对

10. **数字签名技术**

   - 基本术语：

     - 明文消息空间 $M$：某个字母表中串的集合
     - 签名空间 $S$：可能的签名集合
     - 签名密钥空间 $K$：用于生成签名的可能密钥集，具体取值 $k$ 需要保密
     - 验证密钥空间 $K’$：用于验证签名的可能密钥集，具体取值 $k’$ 需要公开
     - 签名函数 $S_K(m \in M)$：从 $M$ 到 $S$ 的有效变换
     - 验证函数 $V_{K’}(m \in M, s \in S)$：一个从 $M \times S$ 到输出 $\{True, False\}$ 的有效变换

   - 签名过程（签名者完成）：

     - 对一条需要签名的消息 $m \in M$ 计算签名 $s=S_k(m)$
     - 将对消息 $m$ 的签名 $(m, s)$ 发送出去

   - 验证过程（验证者完成）：

     - 得到对应签名者的验证算法 $V_{k’}$ ，计算 $u=V_{k’} (m, s)$
     - 如果 $u=True$，接受签名；如果 $u=False$，拒绝签名

   - 签名函数和认证函数必须满足的性质：

     - 当且仅当 $V_{k’} (m, s)=True$ 时，$s$ 是对消息 $m$ 的合法签名
     - 对于任何签名者以外的实体得到任意的一组 $m_f$ 和 $s_f$ 满足 $V_{k’} (m_f, s_f)=True$ 是计算不可能的

   - 数字签名的争议解决：

     如果签名者和验证者对签名发生争议，可由验证者带签名 $(m, s)$ 提交给可信任第三方（TTP），由 TTP 验证该签名，最后进行仲裁

11. **鉴别或实体认证**

    - 概念：

      鉴别或实体认证是一个过程，在这个过程中一方通过获得一些确定的证据来确认参加实体认证的另一方的身份，而具有相应身份的实体也确实就是正在参与这一认证过程的另一方

    - 安全目标：

      - 在宣称者 $A$ 和验证者 $B$ 都诚实的执行认证时，$A$ 能向 $B$ 成功的证明自己，也就是 $B$ 将完成执行并接受 $A$ 所宣称的身份
      - 不可转移性：验证者 $B$ 不能从与宣称者 $A$ 交互中获得的信息，成功地向第三方 $C$ 来冒充 $A$
      - 不可冒充性：任何一个非宣称者 $A$ 的 $C$ 想通过扮演 $A$ 的身份，通过验证者 $B$ 的认证让 $B$ 接受 $A$ 的身份的可能性可以忽略
      - 即使如下情况存在，以上三个条件仍然成立:
        - 宣称者 $A$ 和验证者 $B$ 之间以前进行的多项式次认证会话且被窃听
        - 冒充击者 $C$ 以前参与了同宣称者 $A$ 或（和）验证者 $B$ 的认证执行
        - 冒充者 $C$ 可能发起多个认证会话并行运行

    - 对认证的常见攻击方法：

      - 重放攻击
      - 平行会话攻击
      - 反射攻击
      - 交错攻击

12. **数据源认证**

    - 定义：

      数据源认证或消息认证技术提供一方通过一些附加的证据确定消息的产生一方的真实身份

13. **密码 Hash 函数技术**

    - 概念：

      Hash 函数 $h()$ 是一个有效的计算方法，它将一个任意长度的二进制位串影射成固定长度的二进制位串，这个固定长度的二进制位串叫 Hash 值

    - 修改发现码（MDC）：

      在一般 Hash 函数的基础上加入以下附加性质：

      - Hash 函数是单向函数，即给定 $y$，找到任意 $x$，满足 $y=h(x)$ 计算不可能
      - 已知 $x$，找 $x'$，满足 $h(x)=h(x')$ 计算不可能
      - 找一任意对 $x$ 和 $x'$ ，满足 $h(x)=h(x')$ 计算不可能

      消息发现码没有秘密密钥

    - 消息认证码（MAC）：

      消息认证码的目的通俗讲就是不附加任何其它机制，确保消息来源的真实性的 Hash 函数

      消息认证码有两个不同功能的参数，即消息和秘密密钥

14. **安全评估模型**

    - 无条件安全（信息论安全）：

      - 无论攻击者具有何种计算能力，都无法破解密码
      - Shannon 证明无条件安全需要私钥加密中密 钥的长度与加密信息的长度相等
      - 私钥加密中的一次一密乱码本（one-time pad）方案是无条件安全的密码
      - 公钥密码体系中没有无条件安全的方案

    - 计算复杂理论安全：

      限定攻击者的计算能力为多项式能力（P），证明破译密码需要指数能力（NP）

    - 规约安全：

      规约破解密码的能力为一个数论中的著名困难问题，如 RSA 问题或 Diffie-Hellman 问题。步骤通常如下：

      - 刻画安全模型
      - 在安全模型下，定义密码算法需要达到的安全目标
      - 描述密码算法
      - 规约密码算法可以达到设定的安全目标

      可以看作放宽条件的计算复杂理论下安全或计算安全的特殊子类，这一方法是目前比较实用的公钥密码分析技术

    - 计算安全：

      在已知的攻击方法和攻击者的计算能力下，攻击密码成功的可能性是可以忽略的

      依赖困难问题，但不存在等价证明，大多数私钥密码属于这一类安全，也称为实践安 全

    - 启发式安全：

      根据列出的著名攻击方法，结合使用的困难问 题对密码进行逐条启发示分析，得出安全结论。 很多高层复杂的密码协议通常采用这种方法，但经过这种分析方法的协议只能得到一定程度的计算复杂安全

      攻击的具体手段和方法可能无法穷尽，设计者即使知道某一个攻击方法未必就可以设计出一个真正能抵抗这一攻击的密码。采用该安全模型设计的密码常常仍然存在漏洞

### 公钥基础设施

1. **概念**

   公钥基础设施是提供公钥加密和数字签名服务的综合系统，目的是为了管理密钥和证书。简称 PKI（Public Key Infrastructure）

   PKI 技术采用证书管理公钥，通过第三方的可信任机构，认证中心 CA（Certificate Authority），把用户的公钥和用户的其他标识信息捆绑在一起，在Internet 网上验证用户的身份

   PKI 是基于公钥算法和技术，为网上通信提供安全服务的基础设施。是创建、颁发、管理、注销公钥证书所涉及到的所有软件、硬件的集合体

   PKI 核心元素是数字证书，核心执行者是 CA 认证机构

2. **数字签名**

   - 签名的概念：

     签名是证明当事人的身份和数据真实性的一种信息

   - 数字签名的概念：

     在以计算机文件为基础的现代事物处理中，应采用电子形式的签名，即数字签名

     数字签名的目的是提供一种手段，使得一个实体把他的身份与某个信息捆绑在一起

     一个信息的数字签名实际上是一个数，它仅仅依赖于签名者的密钥和被签名的消息

   - 数字签名的性质：
     - 签名者事后不能否认自己的签名
     - 其他人不能伪造签名
     - 当通信双方为签名真伪发生争执时，可以由第三方解决争端

3. **X.509 证书**

   - 来源：

     X.509公钥证书是 ISO 和 CCITT/ITU-T 的 X.500 目录系列标准的一部分

   - 包含的内容：

     - X.509 版本号

     - 证书持有人的公钥：包括证书持有人的公钥、算法的标识符和其他相关的密钥参数

     - 证书的序列号：由 CA 给予每一个证书分配的唯一 的数字型编号

     - 主体信息：证书持有人唯一的标识符（DN）。这个名字在Internet上应该是唯一的

     - 证书的有效期

     - 认证机构

     - 发布者的数字签名：这是使用发布者私钥生成的签名，以确保这个证书在发放之

       后没有被撰改过

     - 签名算法标识符

4. **撤销证书**

   - 原因：

     - 密钥泄露：证书的私钥泄露或被破坏
     - 从属变更：某些关于密钥的信息变更，如机构从属变更等
     - 终止使用：该密钥对已不再用于原用途，或者证书的有效期已到
     - CA本身原因:由于CA系统私钥泄露， 在更新自身密钥和证书的同时，必须用新的私钥重新签发所有它发放的下级证书
     - CA有理由怀疑证书细节不真实、不可信
     - 证书持有者没有履行其职责和登记人协议
     - 证书持有者死亡、违反电子交易规则或者已经被判定犯罪

   - 方法：

     当证书被取消时，实际上是将此证书序列号放入由 CA 签发的 CRL（Certificate Revocation List，证书作废表，或证书黑名单表）中

     这也是序列号唯一的原因

### 密钥交换协议

1. **概述**

   - 基本概念：

     一般是使用公钥密码或其他方法来确立一个适用于对称密码的共享密钥，即会话密钥（Session Key）。建立这种仅用于一次会话的会话密钥机制就是密钥交换协议

     所谓密钥交换（Key Exchange），也称密钥协商（Key Agreement），是一种协议，利用这种协议，通信双方（或多方）在一个公开的信道上通过相互传递某些信息来共同建立一个共享的秘密密钥，该密钥的值是关于双方提供输入的一个函数，并将用于对称密码协议中以实现保密性、数据完整性等密码服务

   - 性质：

     - 若将协商出来的密钥应用于其他密码协议中，不应该降低这些密码协议的安全性
     - 假设 $k$ 表示 $A$ 和 $B$ 在密钥交换协议执行完毕后建立的共享密钥，需要满足下列安全需求：
       - 只有 $A$ 和 $B$ 知道 $k$：保证参与者知道自己将要通信的目标主体
       - $A$ 和 $B$ 确保对方知道 $k$：参与者知道目标主体参与了当前通信，并对当前通信作出了回应
       - $A$ 和 $B$ 知道 $k$ 是新生成的：当一个密钥是共享密钥，并用于大量数据加密时，只能使用较短时间。这是密钥管理的一个基本原则，原因有：
         - 如果一个密钥是共享的，那么即使共享的一方 $A$ 在密钥的管理和使用中非常谨慎，但在 $A$ 的控制之外，另一个共享者 $B$ 的不谨慎而泄漏了这个密钥的话仍会导致 $A$ 的安全得不到保障
         - 在保密通信中，通常大多数数据包含已知的或可以预料的信息或结构，这类数据的加密使得密钥成为密码分析的对象，加密密钥使用过久将会降低密码分析的困难性

   - 密钥建立协议的基本目标：

     - 隐式密钥认证：协议参与的一方要确信只有身份确定的协议参与的另一方才能知道共享密钥
     - 密钥确认：协议参与的一方要确认协议参与的另一方已经拥有了共享的密钥
     - 显示密钥认证：同时提供隐式密钥认证和密钥确认

   - 密钥建立协议的分类：

     - 密钥传输协议：群体中的一个实体生成一个密钥，然后将其传送给所有其他实体
     - 密钥协商协议：群体中的所有实体参与生成一个密钥，并共享这个密钥
     - 混合协议：群体中多于一个，但少于全部的实体参与生成一个密钥，然后传送给其他所有实体

2. **两方 Diffie-Hellman 协议**

   - 原理：基于离散对数问题的密钥交换协议，Diffie-Hellman 密钥交换协议

     - 通信双方 $A$ 和 $B$ 约定素数阶有限域 $F_P$ 和乘法循环群 $F^*_P$ 的任一生成元 $g$
     - $A$ 在 $[1, p-2]=\{1, 2, \cdots , p-2\}$ 中选择一个随机数 $a$，计算 $g_A=g^a \pmod p$，将 $g_A$ 发送给 $B$
     - $B$ 在 $[1, p-2]=\{1, 2, \cdots , p-2\}$ 中选择一个随机数 $b$，计算 $g_B=g^b \pmod p$，将 $g_B$ 发送给 $A$
     - $A$ 计算 $k=g^a_B \pmod p=g^{ab} \pmod p$
     - $B$ 计算 $k=g^b_A \pmod p=g^{ab} \pmod p$

   - 会话密钥生成：

     在任何密钥协商协议中，交互双方 $A$ 和 $B$ 一般不会直接将协商出来的共享秘密值 $k$ 用于保密通信，而是将它作为输入，经过一个 Hash 函数（密钥导出函数，KDF）计算后输出 $H(k)$ 作为会话密钥

   - 对于攻击的抵抗能力：

     - 被动攻击：

       由于双方的秘密指数是保密的，被动攻击者想要得到共享密钥，就意味着求解离散对数问题。因此，这个协议的安全性依赖于求解离散对数的困难性

       由于攻击者可以同时截获 $p$、$g$、$g_a$、$g_b$，此时攻击者如果能够计算 $k=g^{ab}$，也就意味着能够求解 CDH 问题（Computational Diffie-Hellman Problem，计算性 Diffie-Hellman 问题）。因此本协议的安全性依赖于更强的假设：CDH 问题是困难的

       当攻击者并不打算计算出 $A$ 和 $B$ 的共享密钥 $k$ 本身，而是想要获取关于该密钥的部分信息，比如其奇偶性等。如果希望攻击者连这个目标都无法实现的话，就必须假设在所使用的循环群中 DDH 问题（Decisional Diffie-Hellman Problem， 决策性 Diffie-Hellman 问题）是困难的

     - 中间人攻击：容易遭受中间人攻击。协议参与者 $A$ 和 $B$ 没有对收到的信息进行认证以确认该消息确实来自指定的通信方

   - 端到端协议：

     - 使用协议参与方的数字签名保证消息来源的真实性 :book:（P26）
     - 可以抵御中间人攻击
     - 是一个三段协议

3. **基于自证明公钥的密钥交换**

   - 原理：Girault 密钥交换协议 :book:（P29）
   - 核心点：尽管可信中心在为 $A$ 或 $B$ 计算 $pub_A$、$pub_B$ 时并没有用到它们的秘密指数 $x_A$、$x_B$，但是它们仍需提交秘密指数给可信中心。这样做的目的是确保请求 $pub_A$、$pub_B$ 的人确实知道 $y_A$、$y_B$ 对应的指数 $x_A$、$x_B$。如果可信中心不要求用户这么做的话，那么基于自证明公钥的各种密码协议极易收到中间人攻击

4. **基于身份的密钥协商**

   - 相关概念：

     - 在一个基于身份的密码协议中，用户的公开身份就是其公钥，私钥由系统的一个 TA（Trusted Authority）为用户生成。所以这个 TA 一般也称为私钥生成器（Private Key Generator, PKG）

     - 目前，绝大多数基于身份的密码方案是采用双线性映射技术设计的：

       设 $q$ 为一大素数，点 $P$ 为 $q$ 阶加法循环群 $G_1$ 的生成元，$G_2$ 为同阶的乘法循环群。我们将具有下面三个性质的函数 $e:G_1 \times G_1 \to G_2$ 称为双线性映射（Bilinear Map），也称双线性配对或双线性对（Bilinear Pairing）：

       - 双线性性：$\forall Q, R \in G_1, a, b \in Z_q, e(aQ, bR)=e(Q, R)^{ab}$
       - 非退化性：$e(P, P) \neq 1$
       - 计算有效性：$\forall Q, R \in G_1$, 存在有效算法计算 $e(Q, R)$

   - 基于身份的非交互密钥分配：
     - 原理：​S​a​k​a​i​ 密钥交换协议​ :book:（P31）
     - 局限性：
       - 通信双方得到的共享密钥 $K_{AB}$ 是静态的，而许多应用需要每次会话均使用一个新鲜的会话密钥，在这种环境下动态的共享密钥是更为恰当的选择
       - 通信双发必须事先在系统中注册并得到了自己的密钥之后，才能以这种方法进行通信
   - 基于身份的两方密钥交换：
     - 原理：Smart 密钥交换协议 :book:（P31）
     - 优点：由于使用了随机数 $a$ 和 $b$，值 $K_A$（也即 $K_B$）不仅与协议参与者的公钥有关，而且具有动态性
     - 缺陷：为完成该协议的一次正确运行，$A$ 和 $B$ 各需要计算两个双线性配对函数值，并向对方发送一个群 $G_1$ 中的元素。但由于计算双线性配对函数值比椭圆曲线群中点耗时得多，所需有较大的时间开销
     - 改进：:book:（P31）只需计算一个双线性配对函数值即可得到

5. **三方密钥交换协议**

   - 三方 Diffie-Hellman 密钥交换
     - 原理：
       - 首先 A、B 和 C 约定一个大素数 p 和一个模 p 的生成元 g 作为公开参数，这些公开参数可以在一组用户中公用
       - $A$ 在 $[1, p-2]=\{1, 2, \cdots , p-2\}$ 中选择一个随机数 $a$，计算 $g_A=g^a \pmod p$，将 $g_A$ 发送给 $B$
       - $B$ 在 $[1, p-2]=\{1, 2, \cdots , p-2\}$ 中选择一个随机数 $b$，计算 $g_B=g^b \pmod p$，将 $g_B$ 发送给 $C$
       - $C$ 在 $[1, p-2]=\{1, 2, \cdots , p-2\}$ 中选择一个随机数 $c$，计算 $g_C=g^c \pmod p$，将 $g_C$ 发送给 $A$
       - $A$ 将 $k_A=g^a_C \pmod p$ 发送给 $B$
       - $B$ 将 $k_B=g^b_A \pmod p$ 发送给 $C$
       - $C$ 将 $k_C=g^c_B \pmod p$ 发送给 $A$
       - $A$ 计算 $k=k^a_C \pmod p=g^{abc} \pmod p$
       - $B$ 计算 $k=k^b_A \pmod p=g^{abc} \pmod p$
       - $C$ 计算 $k=k^c_B \pmod p=g^{abc} \pmod p$
     - 缺陷：同两方 Diffie-Hellman 协议类似，由于这种方法没有使用认证机制，所以易受中间人攻击
   - 基于双线性配对的密钥交换
     - 原理：Joux 密钥交换协议 :book:
     - 优势：三方只需要一轮交互即可实现密钥共享
     - 缺陷：没有使用认证机制，不能抵抗中间人攻击

6. **多方密钥交换协议**

   - 概述：多方密钥交换也称群 / 组密钥交换

   - 多方 Diffie-Hellman 密钥交换

     - 原理：也是将两方 Diffie-Hellman 密钥交换协议推广到多方的情景，其思路是为每一个参与方各选择一个秘密指数 $x_i$，最后构造出一个秘密值 $g^{x_1x_2 \cdots x_n}$：
       - 令 $G$ 是一个阶为素数 $q$ 的乘法循环群，$g$ 为其任一生成元，群成员为 $U_1,U_2, \cdots ,U_n$
       - 第 $1$ 轮：$\forall 1 \leq i \leq n$，$U_i$ 选择 $x_i \in {_RZ^*_q}$，计算 $g^{x_i}$，将 $g^{x_i}$ 发送给 $U_{(i+1) \bmod n}$
       - 第 $k \in (1,n-1]$ 轮：$\forall 1 \leq i \leq n$，$U_i$ 计算 $g^{\Pi \{x_j | j \in ((i-k) \bmod n,i]\}}$，将结果发给 $U_{(i+1) \bmod n}$
       - 在 $n-1$ 轮后，所有参与者可以计算出一个共同的密钥 $K=g^{x_1x_2 \cdots x_n}$
     - 优势：可以抵抗被动攻击者的攻击
     - 缺陷：效率低下。经过长达 n-1 轮交互之后，每个参与者需要发送 n-1 个消息，计算 n 个模数才能得到共享的秘密值

   - Burmester-Desmedt 多方密钥交换

     - 原理：:book:（P35）

       与 Diffie-Hellman 密钥交换协议不同，本协议中各持有一个秘密指数 $x_i$ 的参与者最终协商的共享秘密值是 $g^{x_1x_2+x_2x_3+ \cdots +x_nx_1 }$ 而并非 $g^{x_1x_2 \cdots x_n}$

     - 优势：在只考虑被动攻击者的情况下是安全的

   - 其他要求

     在设计多方密钥交换协议时，除了关注其安全性、有效性之外，还必须注意到对成员关系动态变化的处理，即允许参与者可以动态地加入和离开用户群体。在一个动态的群体中，当成员关系有变化时必须确保会话密钥得到更新，密钥更新必须满足这样两个条件：

     - 离开了的成员无法获取之后的会话密钥
     - 新加入的成员无法获取先前的会话密钥
   
7. **思考题**

   - 试述密钥交换协议的目的
   - 写出椭圆曲线上的 Diffie-Hellman 密钥交换协议
   - 举例说明隐式密钥认证的涵义
   - 试构造一个能够抵抗中间人攻击的三方密钥交换协议
   - 应用双线性映射技术设计一个群密钥交换协议
   - 试描述成员动态变化环境下的群密钥交换协议应具备的安全性

### 实体认证协议

1. **概述**

   - 认证：

     - 所谓认证，是一个通信过程，根据这个过程，一个实体（通常被称为验证者，Verifier）$B$ 验证了另一个实体（通常被称为声称者，Claimant）$A$ 声称的某种属性

     - 认证至少涉及两个通信实体
     - 如果认证是验证消息的某种声称属性，则称这种认证为数据源认证（Data-origin Authentication）也称消息认证（Message Authentication）；如果认证是验证原告所声称的身份，则称这种认证为实体认证（Entity Authentication）

   - 实体认证：

     是指一个通信过程或协议，通过这个过程，一个实体 $B$ 和另一个实体 $A$ 建立一种真实通信，使得 $B$ 能够验证 $A$ 确实就是他要与之通信的那个实体；而不是 $A$ 的实体无法向 $B$ 证明自己就是 $A$

   - 对认证协议的攻击：

     通常所说的对认证协议的成功攻击，不是指攻破协议所使用的密码算法，而是指攻击者能够在不攻破密码算法的前提下，以未经授权且不被察觉的方式获得了某种信任或是破坏了某种密码服务。攻击者能够这样做的原因就在于认证协议存在设计上的缺陷

   - 实体认证（Entity Authentication）和身份识别（Identity Identification）的区别：
     - 从概念上看：身份识别是一种声明自己身份、声称自己是谁的行为，而实体认证是验证所声称身份是否真实的过程。身份识别中，所声称的身份信息是公开的；而在实体认证中交互双方可能会用到只有他们才知道的共享秘密信息
     - 从能抵抗的威胁来看：对于实体认证来说，当声称者和验证者共享秘密需要合作的时候，认证协议只能抵抗来自外部的威胁，一般不考虑内部攻击，即验证者是不诚实的情况；身份识别协议可以考虑来自内部的攻击，即验证者可以是不诚实的
     - 假设两类协议都是安全的，从协议执行结束时的效果来看：对于实体认证，声称者 $A$ 能够向验证者 $B$ 证明自己确实是 $A$，但其他人则无法冒充 $A$ 使 $B$ 相信自己在和 $A$ 会话；对于身份识别，声明自己身份的 $A$ 可以使验证者 $B$ 相信他确实是 $A$，但 $B$ 事后无法使其他人相信自己是 $A$，即无法成功假冒 $A$
     - 从使用场景来看：实体认证有时会结合密钥交换一起使用以产生一个经过认证的会话密钥；而身份识别则一般不考虑具体目的

2. **基于对称密码的实体认证**

   - 概述：

     假设一个主体是声称自己是 $A$，另一个主体 $B$ 是验证者，$B$ 要验证对方确实是 $A$。A 和 $B$ 使用堆成密码技术，共享密钥为 $K_{AB}$，并约定一种对称加密体制 $SE$

   - 基于对称密码的一次传输单向认证：
     - 原理：$A$ 需要在加密的明文串中加入其他判断性的数据，比如时间戳和序列号
     - 流程：
       - $A$ 计算 $SE_{K_{AB}}([T_A|SN_A],ID_A)$，将结果发送给 $B$。$[T_A|SN_A]$ 表示 $A$ 可以选择一个时间戳（Timestamp）$T_A$ 或者序列号（Sequence Number）$SN_A$
       - 如果使用时间戳，$B$ 对接收到的数据进行解密运算，将得到的 $T_A$与本地时间进行比较。若时间间隔足够小，则意味着该密文是新近产生的，而能够产生这一密文的人只有 $A$，因此 $B$ 相信 $A$ 就是本次通信的意定通信方
       - 如果使用序列号，$A$ 和 $B$ 维护某个同步的序列号，这样序列号 $SN_A$ 以一种 $B$ 知道的方式增加。在对序列号成功接收和验证之后，因此 $B$ 相信 $A$ 就是本次通信的意定通信方。最后，$A$ 和 $B$ 均需要将序列号管理器更新到某个新的状态
     - 说明：
       - 由于只需要一次传输，该协议是非交互的
       - 时间戳方法的缺点是通信双方需要同步时钟，并且需要对时钟进行安全维护
       - 序列号方法也存在同步和维护的问题
   - 基于对称密码的两次传输单向认证：
     - 原理：在序列号维护或时间戳同步不太现实的情况下，可以使用随机数达到同样的目的，但是由于需要对所使用随机数进行验证，所以协议参与方需要进行交互
     - 流程：
       - $B$ 选择一个一次性随机数 $N_B$，将 $N_B$ 发送给 $A$
       - $A$ 将 $SE_{K_{AB}}(N_B,ID_A)$ 返回给 $B$
       - $B$ 对返回结果执行解密运算，如果所得结果中能够正确显示自己所选取的一次性随机数 $N_B$，则接受这个声称者确实是 $A$
     - 说明：
       - 这个协议就是一个典型的询问-应答机制（Challenge-Response Mechanism），B 是协议的发起者（Initiator），A 是响应者（Responder）
   - 基于对称密码的两次传输双向认证：
     - 流程：
       - $A$ 计算 $SE_{K_{AB}}([T_A|SN_A],ID_A)$，将所得结果发送给 $B$
       - $B$ 计算 $SE_{K_{AB}}([T_B|SN_B],ID_B)$，将所得结果发送给 $A$
     - 说明：由于协议参与方各自仅有一次消息发送，所以只能在明文中嵌入时间戳或序列号，而不能是一次性的随机数。这就存在同步和维护的问题
   - 基于对称密码的三次传输双向认证：
     - 流程：
       - $B$ 选择一个一次性随机数 $N_B$，将 $N_B$ 发送给 $A$
       - $A$ 选择一个一次性随机数 $N_A$，将 $SE_{K_{AB}}(N_A,N_B,ID_A)$ 返回给 $B$
       - $B$ 对 $SE_{K_{AB}}(N_A,N_B,ID_A)$ 执行解密运算，如果得到自己选取的随机数 $N_B$，则认为 $A$ 是真实的，然后将 $SE_{K_{AB}}(N_B,N_A)$ 发送给 $A$
       - $A$ 对 $SE_{K_{AB}}(N_B,N_A)$ 执行解密运算，如果所得结果中能够正确显示 $B$ 发送给自己的随机数 $N_B$ 以及自己所选取的一次性随机数 $N_A$，则认为 $B$ 是真实的

3. **基于 Hash 函数的实体认证**

   - 概述：

     使用 Hash 函数实现实体认证时设计协议的方式与基于对称密码的方法完全类似，只是将 加密操作 $SE_{K_{AB}}(\cdot)$ 换成了 Hash 函数 $Hash_{K_{AB}}(\cdot)$，将解密运算换成了重构运算

   - 基于 Hash 函数的一次传输单向认证
   - 基于 Hash 函数的两次传输单向认证
   - 基于 Hash 函数的两次传输双向认证
   - 基于 Hash 函数的三次传输双向认证

4. **基于公钥密码的实体认证**

   - 概述：

     使用对称密码或 Hash 函数设计实体认证协议均需要一个前提条件，即通信双方有共享密钥。如果这个前提条件不满足的话，可以使用非对称密码来实现实体认证

     由于公钥证书架构（Public-Key Certification Framework）的存在，通信双方可以通过该架构获取对方的公钥

     $Cert_A$ 表示 $A$ 在该架构下的证书，$Sign_A(\cdot)$ 表示 $A$ 使用自己的私钥执行了一次签名运算

   - 基于公钥密码的一次传输单向认证：

     - 流程：
       - $A$ 计算 $Sign_A([T_A|SN_A],ID_A)$，将所得结果同 $[T_A|SN_A]$、$ID_A$ 以及自己的公钥证书 $Cert_A$ 一起发送给 $B$
       - $B$ 收到 $A$ 发来的数据后，可以使用这些数据执行签名验证运算，如果 $A$ 的数字签名通过了验证，则相信本次通信确实就是与 $A$ 进行的

   - 基于公钥密码的两次传输单向认证：

     - 流程：
       - $B$ 选择一个一次性随机数 $N_B$，将 $N_B$ 发送给 $A$
       - $A$ 将 $Cert_A$ 和 $Sign_A(N_B,ID_A)$ 返回给 $B$
       - $B$ 执行签名验证运算，如果 $A$ 的签名通过验证，则 $B$ 接受此次运行
     - 缺陷：由于 $A$ 对于签名内容中的随机数没有任何控制权，一些不诚实的 $B$ 可以利用这个过程让 $A$ 对一些非法信息进行签名，欺骗 $A$ 使其蒙受损失
     - 改进：
       - $B$ 选择一个一次性随机数 $N_B$，将 $N_B$ 发送给 $A$
       - $A$ 选择一个一次性随机数$N_A$，$A$ 将 $Cert_A$、$N_A$、$N_B$ 和 $Sign_A(N_A,N_B,ID_A)$ 返回给 $B$
       - $B$ 执行签名验证运算，如果 $A$ 的签名通过验证，则 $B$ 接受此次运行

   - 基于公钥密码的两次传输双向认证：

     就是基于公钥密码的一次传输单向认证的两次独立使用

   - 简单地重复单向认证实现双向认证的缺陷：

     可能遇到 Wiener 攻击 :book:（P46）

   - 基于公钥密码的三次传输双向认证：
     - 流程：
       - $B$ 选择一个随机数 $N_B$，将 $N_B$ 发送给 $A$
       - $A$ 选择一个随机数$N_A$，$A$ 将 $Cert_A$、$N_A$、$N_B$ 和 $Sign_A(N_A,N_B,ID_A)$ 返回给 $B$
       - $B$ 验证 $A$ 的数字签名，如果签名有效，则认为 $A$ 是真实的；然后 $B$ 将 $Cert_B$、$N_B$、$N_A$ 和 $Sign_B(N_B,N_A,ID_B)$ 返回给 $A$
       - $A$ 利用接收到的数据对 $B$ 的数字签名执行验证运算，如果签名有效，则认为 $B$ 是真实的
     - 说明：
       - 通过随机数的重用，两次单向协议的使用就不再独立，而是上下文关联的了，从而使得 Wiener 攻击方法失效
       - $A$ 需要对 $N_B$ 进行保存，以便在后续进行确认

5. **基于口令的实体认证**

   - 概述：

     在这种类型的认证中，用户和计算机共享某个口令，这个口令相当于一个长期使用但又相对较短的对称密钥。如果用户 $U$ 希望使用主机 $H$ 的服务，$H$ 必须事先对 $U$ 进行初始化，发给 $U$ 一个口令 $PW_U$

   - 一个直接的基于口令的认证协议：

     - 流程：
       - $U \to H:ID_U$
       - $H \to U:$ “请输入口令”
       - $U \to H:PW_U$
       - $H$ 从自己的口令文档中查找是否存在与 $U$ 的输入 $(ID_U,PW_U)$ 相匹配的记录，如果有，则允许 $U$ 使用自己的服务
     - 缺陷：在现代计算机网络中已不可行

   - 使用单向函数：

     - 概述：为了决定用户是否可以使用自己的服务，主机 $H$ 只需要具备区分有效口令和无效口令的能力即可，而无需知道口令本身。因此，可以让主机存储口令的单向函数值，而不是存储口令本身。
     - 流程：
       - $U \to H:ID_U$
       - $H \to U:$ “请输入口令”
       - $U \to H:PW_U$
       - $H$ 将接收到的 $PW_U$ 作为单向函数 $OWF(\cdot)$ 的输入，计算其值，然后从自己的口令文档中查找是否存在相匹配的记录 $(ID_U,OWF(PW_U))$，如果有，则允许 $U$ 使用自己的服务
     - 缺陷：在线窃听的攻击者仍然可以获得 $U$ 发送给 $H$ 的以明文显示的口令

   - 同时使用单向函数和加盐：

     - 概述：攻击者可以采取字典攻击对使用单向函数的口令认证进行攻击，所以加入加盐的机制来抵抗这一攻击
     - 流程：
       - $U \to H:ID_U$
       - $H \to U:$ “请输入口令”
       - $U \to H:PW_U$
       - $H$ 将接收到的 $PW_U$ 作为单向函数 $OWF(\cdot)$ 的输入，计算其值，然后从自己的口令文档中查找是否存在相匹配的记录 $(ID_U,salt,OWF(PW_U,salt))$，如果有，则允许 $U$ 使用自己的服务
     - 缺陷：在线窃听的攻击者仍然可以获得 $U$ 发送给 $H$ 的以明文显示的口令

   - 使用 Hash 链：

     - 概述：使用户每次使用不同的口令，即使攻击者窃听到了本次通信的口令，而该口令之后不能再用，所以不会影响到用户的下次登录时的认证，也成功阻止了口令的被窃。这就是一次性口令的思想
     - 流程：
       - $U \to H:ID_U$
       - $H \to U:c,$ “请输入口令”
       - $U \to H:Hash^{c-1}(PW_U)$
       - $H$ 从自己的口令文档中找到该用户的记录 $(ID_U,c,Hash^c(PW_U))$，计算 $Hash(Hash^{c-1}(PW_U))$，如果所得结果等于 $Hash^c(PW_U)$，则允许 $U$ 使用自己的服务
       - $H$ 将保存的口令记录更新为 $(ID_U,c-1,Hash^{c-1}(PW_U))$
     - 关键点：由于用户 $U$ 发送给主机的值 $Hash^c(PW_U)$ 只使用一次，而 Hash 函数是单向的，所以在线的窃听者不会从 $Hash^c(PW_U)$ 得到有用的信息；同样的原因，即使窃听者窃取了主机保存的口令表，也无法得到口令 $PW_U$

   - 加密的密钥交换协议：

     - 概述：加密的密钥交换（Encrypted Key Exchange, EKE）。该协议既具有实体认证功能，也提供密钥协商性质。该协议约定了两种加密体制，$SE$ 为私钥加密体制，$AE$ 为公钥加密体制。协议执行结束后，用户 $U$ 和主机 $H$ 将完成双向实体认证，并且得到一个共享的密钥
     - 流程：
       - $U$ 生成一个随机数 $PK$，将自己的身份 $ID_U$ 和 $SE_{PW_U}(PK)$ 发送给 $H$
       - $H$ 对 $SE_{PW_U}(PK)$ 执行解密操作，得到 $PK$，将 $SE_{PW_U}(AE_{PK}(K))$，发送给 $U$，其中 $K$ 为 $H$ 产生的随机对称密钥
       - $U$ 利用 $PW_U$ 和 $PK$ 从 $SE_{PW_U}(AE_{PK}(K))$ 中恢复出密钥 $K$，将 $SE_K(N_U)$ 发送给 $H$，其中 $N_U$ 为用户 $U$ 产生的随机数
       - $H$ 从 $SE_K(N_U)$ 中恢复出 $N_U$，将 $SE_K(N_U,N_H)$ 发送给 $U$，其中 $N_H$ 为 $H$ 产生的随机数
       - $U$ 从 $SE_K(N_U,N_H)$ 中恢复出 $N_H$，将 $SE_K(N_H)$ 发送给 $H$
       - 如果 $H$ 能够从 $SE_K(N_H)$ 中恢复出 $N_H$，则允许 $U$ 使用自己的服务，并且于 $U$ 使用共享的秘密 $K$ 处理之后进行的安全通信
     - 关键点：在协议的前两步中用户 $U$ 对随机公钥的加密和主机 $H$ 对随机会话密钥的加密，即对口令 $PW_U$ 执行加盐操作，使得口令 $PW_U$ 与协议中传输的所有消息都是统计独立的，我们就获得了关于口令的信息论安全性，被动攻击者肯定无法对此协议采用任何有效的攻击

6. **对实体认证协议的攻击**

   - 消息重放攻击（Message Replay Attack）：
     - 概述：攻击者预先记录了欲攻击协议先前某次运行中的消息，然后在该协议新的运行中重放所记录下来的消息，最后可以导致通信双方不存在真实通信，即认证失败
   - 中间人攻击（Man-In-The-Middle Attack）：
     - 概述：攻击者处于通信双方的中间，他将 $A$（或 $B$）所提出的困难问题转交给 $B$（或 $A$）回答，然后将收到的答案或是对答案进行简单处理后的结果作为自己的应答返回给 $A$（或 $B$），以此达到攻击的效果
     - 例子：
       - 对 Diffie-Hellman 密钥交换协议的攻击：:book:（P25）
       - 对使用 Hash 链的基于口令的实体认证协议的攻击：:book:（P57）
   - 平行会话攻击（Parallel Session Attack）：
     - 概述：是指在攻击者的操控下，被攻击协议的两个或多个运行并发执行，他可以从其中某次运行中传输的消息得到其他运行中所需要的应答
     - 例子：
       - 对 Woo-Lam 协议的攻击和协议的改进 :book:（P57）
   - 反射攻击（Reflection Attack）：
     - 概述：指的是当一个诚实的实体 $A$ 给另一个通信方 $B$ 发送消息（从而 $B$ 可以用来完成某些操作）时，攻击者 $E$ 会截获该消息，然后将消息（或是稍作处理后的消息）返回给消息的产生者 $A$，而 $A$ 却不会意识到这个消息是他自己产生的
     - 例子：
       - 对改进后的 Woo-Lam 协议的攻击 :book:（P60）
   - 交错攻击（Interleaving Attack）：
     - 概述：
       - 指在 $E$ 的操纵下，某个被攻击协议的两次（或多次）运行按交错的方式执行。例如一次运行的通信双方为 $A$ 和 $E$，第二次运行中的通信双方为 $E$ 和 $B$。$E$ 可以构造某条消息发送给第一次运行中的主体 $A$，并得到其应答，这个应答可能对于第二次运行中的 $E$ 是有用的
       - 交错攻击对于消息交换的顺序是敏感的，这是交错攻击区别于平行会话攻击或是反射攻击的很重要的一点
       - 在中间人攻击中，协议发起方是通信双方 $A$ 和 $B$ 中的一个，而攻击者并不是协议发起方；而在交错攻击中，攻击者在两次协议运行中均是发起方
     - 例子：
       - 对基于公钥密码的三次传输双向认证的 Wiener 攻击 :book:（P45）

7. **思考题**

   - 试阐述认证协议中关于“角色”的理解
   - 试阐述实体认证与密钥交换间的紧密联系
   - 举例说明实体认证协议中时间戳与序列号使用的优缺点
   - 举例说明加盐操作的作用
   - 试解释 Hash 链的涵义与用途
   - 谈谈交错攻击与平行会话攻击以及反射攻击之间的区别

### 比特承诺

1. **概述**
   - 基本思想：
     - $A$ 发送给 $B$ 一个证明，用来向 $B$ 做出承诺：承诺的内容是一个比特，即 $0$ 或者 $1$
     - 在 $A$ 打开此承诺之前，$B$ 无法得知 $A$ 承诺的到底是 $0$ 还是 $1$
     - $A$ 也不能打开一个与最初承诺相反的比特
   - 两个阶段：
     - 承诺阶段（Commit）：发送方 $A$ 选择一个要承诺的比特 $b \space (b=0 \or b=1)$，并把能表示该比特的消息 $c$ 发送给 $B$
     - 打开阶段（Open）：$A$ 把打开承诺的消息 $d$ 和 $b$ 发送给 $B$，$B$ 用 $d$ 打开 $c$ 并验证 $b$ 是否是 $A$ 承诺的比特
   - 安全性质：
     - 隐藏性（Hiding）：在协议的承诺阶段结束时，接收方得不到发送方承诺的比特的值。即使是一个不诚实的接收方也要满足这个条件。称一个承诺方案是完善隐蔽的是指接收方不能从 $c$ 中获取关于比特 $b$ 的任何有用信息
     - 绑定性（Binding）：给定承诺阶段的交互信息，接收者只能接受一个合法的承诺，即发送者不能在打开阶段改变自己承诺的比特
     - 当且仅当该协议同时满足隐藏性和绑定性时一个比特承诺协议才被称为是安全的
     - 如果一个比特承诺协议的隐藏性（绑定性）的成立依赖于某个计算困难性假设，就说它是计算上隐藏的（计算上绑定的）
     - 如果一个比特承诺协议的隐藏性（绑定性）的成立不依赖于任何计算困难性假设，就说它是信息论上隐藏的（信息论上绑定的）
   - 其他要点：
     - 协议的初始化应满足公平性，由可信第三方完成
     - 对于验证者是不公平的，如果承诺者拒绝打开承诺，则验证者什么都得不到
2. **常用比特承诺协议**
   - 使用对称加密函数：
     - 概述：协议在初始阶段，参与协议的双方在可信第三方的帮助下选择一个安全的对称加密算法 $E$ 和相应的解密算法 $D$
     - 流程：
       - 承诺阶段：
         - $B$ 产生一个随机比特串 $r$，并把它发送给 $A$
         - $A$ 选择想承诺的比特 $b$，并随机产生一个密钥 $K$，用随机密钥 $K$ 对消息 $r \| b$ 加密，并将 $E_K(r \| b)$ 传送给 $B$
       - 打开阶段：
         - $A$ 发送密钥 $K$ 给 $B$
         - $B$ 解密消息以揭示比特，同时检验解密结果中包含的随机串是否与他产生的随机串 $r$ 一致，如果一致，则认为承诺的比特有效
     - 关键点：如果消息不包含 $B$ 的随机串，$A$ 能够秘密地用一系列密钥解密他交给 $B$ 的消息，直到找到一个可以伪造承诺比特的密钥为止。由于比特只有两种可能的值，所有只需试几次就能以很大概率找到一个。而加入随机串后，$A$ 必须能找到一个新的消息，这个消息不仅使他承诺的比特反转，而且准确地产生 $B$ 的随机串，如果加密算法足够安全，这种机会是极小的
   - 使用单向散列函数：
     - 概述：$A$ 使用 Hash 函数阻止 $B$ 对函数求逆并确定承诺的比特。协议在初始阶段，参与协议的双方在可信第三方的帮助下选择一个安全的、无碰撞的单向散列函数 $H$
     - 流程：
       - 承诺阶段：
         - $A$ 产生两个随机比特串 $r_1$ 和 $r_2$
         - $A$ 产生消息 $(r_1 \| r_2 \| b)$，该消息由随机串和 $A$ 希望承诺的比特 $b$（实际上可能是几比特）组成
         - $A$ 计算消息的 Hash 函数值 $H(r_1 \| r_2 \|b)$，将结果和其中一个随机串 $r_1$ 发送给 $B$
       - 打开阶段：
         - $A$ 将原消息 $(r_1 \| r_2 \| b)$ 发送给 $B$
         - $B$ 计算消息的 Hash 函数值，并将该值及 $r_1$ 与之前收到的承诺进行比较。如果一致，则认为承诺的比特有效
     - 关键点：
       - $A$ 不可能否认自己的承诺，并找到另一个消息 $(r_1 \| r'_2 \| b')$ 满足 $H(r_1 \| r_2 \| b)=H(r_1 \| r'_2 \| b')$
       - $A$ 将 $r_1$ 发送给 $B$，但是 $A$ 保持 $r_2$ 是秘密的。如果不这样，那么 $B$ 能够计算 $H(r_1 \| r_2 \| b)$ 和 $H(r_1 \| r_2 \| \bar{b})$，并比较哪一个是从 $A$ 处接收的
     - 优势：$B$ 不必发送任何消息
   - 使用伪随机数发生器：
     - 概述：协议在初始阶段，参与协议的双方在可信第三方的帮助下选择伪随机数发生器 $G$，再选择随机串 $R$，$R$ 的长度足够大
     - 流程：
       - 承诺阶段：
         - $A$ 选择所需的承诺比特 $b$，并产生随机数 $s$ 作为伪随机数发生器所需的种子
         - $A$ 计算：如果 $b=0$，则 $c=G(s)$；如果 $b=1$，则 $c=G(s) \otimes R$。这里 $c$ 即为 $A$ 的承诺。$A$ 将 $c$ 发送给 $B$
       - 打开阶段：
         - $A$ 将 $s$ 和 $b$ 发送给 $B$，打开承诺
         - $B$ 验证 $c$ 的计算是否与收到的承诺一致，如果一致，则认为承诺的比特有效
     - 关键点：
       - $B$ 在未获知 $b$ 之前，并不能区分 $G(s)$ 和 $G(s) \otimes R$
       - 若 $A$ 想要更改他的承诺从 $0$ 变到 $1$，就需要计算 $s'$ 使得 $c=G(s')=G(s) \otimes R$，而这是困难的
     - 扩展到承诺多个比特的改进：:book:（P67）
   - Pedersen 承诺协议：
     - 概述：基于离散对数问题来构造。在协议初始阶段，参与协议的双方在可信第三方的帮助下选择大素数 $p$，$g$ 是群 $Z^*_p$ 的生成元。从群 $Z^*_p$ 中随机选择元素 $y$
     - 流程：
       - 承诺阶段：
         - $A$ 选择所需的承诺比特 $b$，并产生随机数 $r \in Z^*_p$
         - $A$ 计算 $c=g^ry^b \pmod p$。$c$ 即为 $A$ 对 $B$ 的承诺。$A$ 将 $c$ 发送给 $B$
       - 打开阶段：
         - $A$ 将 $b$ 和 $r$ 发送给 $B$，打开承诺
         - $B$ 验证 $c$ 的计算是否与收到的承诺一致，如果一致，则认为承诺的比特有效
     - 关键点：
       - 因为 $r$ 是随机选择的，所以 $c_0=g^r \pmod p$ 和 $c_1=g^ry \pmod p$ 都是 $Z^*_p$ 中的随机数，$B$ 不能区分
       - 若 $A$ 想要更改他的承诺从 $0$ 变到 $1$，就需要计算 $r'$ 使得 $g^r=g^{r'}y$，即 $y=g^{r-r'}$，这就意味着 $A$ 需要计算随机数 $y$ 的离散对数，而这是困难的
     - 扩展到承诺多个比特的改进：:book:（P69）
3. **比特承诺协议的应用**
   - 电子拍卖：
     - 密封式电子拍卖协议：
       - 概述：投标阶段和打开密封阶段
       - 性质：
         - 正确性：协议应能够正确地确定拍卖者中的赢家，并正确地确定相应的竞拍价格
         - 竞拍价格的保密性：除了竞拍者中的赢家的身份以及最终的竞拍价格之外，其他竞拍者的身份和其投标价格都应该保密
         - 公开验证性：任何一个竞拍者都可以验证协议是否执行正确
       - 例子：:book:（P70）
   - 其他应用：
     - 公平的抛硬币协议
4. **思考题**
   - 想想生活中能用到比特承诺的地方，扩展比特承诺的应用范围
   - 将使用对称加密算法的比特承诺协议扩展为一次可以承诺多个比特的协议
   - 使用比特承诺协议构造公平抛硬币协议，协议应该满足抛币结果的随机性和公平性

### 高级签名协议

1. **数字签名**

   - 组成：

     一般一个数字签名体制包括三个算法：

     - 密钥生成算法（Keygen）
     - 签名算法（Sign）
     - 验证算法（Verify）

   - 安全需求：

     攻击者即使知道签名人的公钥和若干个有效信息-签名对也无法伪造该签名人的有效签名

   - 安全服务：
     - 认证性
     - 完整性
     - 不可否认性

2. **盲签名**

   - 概述：

     一个盲签名体制是用户 $User$ 和签名人 $Signer$ 之间的一个交互协议。如果协议正确执行，持有某个消息 $m$ 的 $User$ 最终将获得签名人 $Signer$ 对消息 $m$ 的签名 $s$，但 $Signer$ 却不知道消息 $m$ 的内容，即便以后将 $(m,s)$ 公开，$Signer$ 也无法追踪消息与自己执行签名过程之间的相互关系

   - 组成：

     - 算法 $Setup$ 是一个概率多项式时间算法，其输出为系统参数 $params$ 和签名人的公、私钥对 $(pk,sk)$
     - 算法 $Sign$ 是一个概率多项式时间的交互协议，公共输入是系统参数和签名人的公钥 $pk$，签名人的秘密输入为自己的私钥 $sk$，用户的秘密输入为待签名消息 $m$。双方交互执行签名协议，在多项式时间内停止，停止时签名人输出签名 $s$
     - 算法 $Verify$ 是一个多项式时间算法，其输入为系统公开参数 $params$、签名人的公钥 $pk$ 以及待验证的消息签名对 $(m,s)$。其输出为 $1$（表示签名有效）或 $0$（表示签名无效），记作 $1 \or 0 \leftarrow Verify(params,pk,m,s)$ 

   - 安全性需求：

     - 正确性（完备性或一致性）：如果 $s$ 是 $Sign$ 算法正确执行后输出的对于消息 $m$ 的签名，则总有 $Verify(params,pk,m,s)$ 
     - 不可伪造性：任意不知道签名人私钥 $sk$ 的人无法有效地计算出一个能够通过签名验证的消息签名对 $(m',s')$
     - 盲性：除请求签名的用户外，任何人（包括签名人）都无法将交互协议 $Sign$ 产生的会话信息（签名人与用户在公共信道上交互的信息的集合）与最终的盲签名正确匹配起来。如果签名人能将其会话信息与最终所得的签名正确匹配，他就能跟踪签名

   - 应用场景：

     - （不可跟踪）电子现金
     - 电子拍卖
     - 电子选举（无记名选举）

   - 基本设计思路：

     - 盲化：在发送消息给签名人之前用户先引入盲化因子，由消息 $m$ 计算出数据 $m'$，发送 $m'$ 给签名人
     - 签名：签名人对 $m'$ 执行签名操作得到签名 $s'$，发回给用户
     - 去盲：用户从 $s'$ 中计算出消息 $m$ 的签名 $s$

   - 基于 RSA 问题的盲签名：

     - $Setup$：

       $Signer$ 选定 $p$，$q$，$d$ 是私钥，$n=pq$ 和 $e$ 是公钥

     - $Sign$：

       - 盲化：$User$ 选定消息 $m$，再任选一随机数 $k$，计算 $m'=k^em \pmod n$，将 $m'$ 发送给 $Signer$
       - 签名：$Signer$ 计算 $s'=m'^d \pmod n$，将结果发送给 $User$
       - 去盲：$User$ 计算 $s=k^{-1}s' \pmod n$，输出消息签名对 $(m,s)$

     - $Verify$：

       给定 $Signer$ 的公钥 $(n,e)$ 和消息签名对 $(m,s)$，如果 $m=s^e \pmod n$，则签名验证者相信这是 $Signer$ 产生的有效签名

   - 基于离散对数的盲签名：

     - 基础知识：
       - 设 $G$ 是一个阶为素数 $p$ 的乘法循环群，其上的 CDH 问题和 DDH 问题分别为：
         - CDH 问题：给定 $G$ 中的 $3$ 个随机元素 $(g,u,v)$，计算 $h=g^{\log_gu\log_gv}$	
         - DDH 问题：给定 $G$ 中的 $4$ 个随机元素 $(g,u,v,h)$，判断属于哪种情况：
           - $(g,u,v,h)$ 是 $G$ 中的随机元素，输出 $0$
           - $(g,u,v,h)$ 满足 $\log_gu=\log_vh$，输出 $1$
       - 给定一个素数阶群 $G$，如果存在一个有效的算法 $V_{DDH}(\cdot)$ 能够求解其上的 DDH 问题，但不存在有效的算法求解其上的 CDH 问题，则将这样的群称为 GDH 群（Gap Diffie-Hellman 群）
       - BLS 体制：$G$ 是 $p$ 阶 GDH 群，$H:\{0,1\}^* \to G^*$ 为一个 Hash 函数，签名人选择 $x \leftarrow {_RZ^*_p}$ 作为自己的私钥，将 $y\leftarrow g^x$ 公开作为自己的公钥；对于任意消息 $m$，其数字签名为 $s=H(m)^x$；给定消息签名对 $(m,s)$，如果 $V_{DDH}(g,y,H(m),s)=1$，则验证者接受该签名
     - $Setup$：设 $G$ 为素数 $p$ 阶的 GDH 群，$g$ 为它的任一生成元，$H:\{0,1\}^* \to G^*$ 为 Hash 函数，$Signer$ 的公、私钥对为 $(y=g^x,x)$
     - $Sign$：
       - 盲化：$User$ 选定消息 $m$，再任选一随机数 $r$，计算 $m'=g^rH(m) $，将 $m'$ 发送给 $Signer$
       - 签名：$Signer$ 计算 $s'=m'^x$，将结果发送给 $User$
       - 去盲：$User$ 计算 $s=s'y^{-r}$，输出消息签名对 $(m,s)$
     - $Verify$：给定 $Signer$ 的公钥 $y$ 和消息签名对 $(m,s)$，如果 $V_{DDH}(g,y,H(m),s)=1$，则签名验证者相信这是 $Signer$ 产生的有效签名

   - 部分盲签名：

     - 概述：
       - 在普通的盲签名体制中，被签名的消息完全由用户控制，签名人对此一无所知，也不知道关于最终签名的任何信息。这有可能成为一个缺点，造成签名被非法使用等问题
       - 在一个部分盲签名方案中，签名人可以在签名中嵌入一个和用户实现约定好的公共信息
     - $Setup$：令 $q$ 为一大素数，点 $P$ 为 $q$ 阶加法循环群 $G_1$ 的生成元，$G_2$ 为同阶的乘法循环群，$e:G_1 \times G_2 \to G_2$ 为双线性映射，$H:\{0,1\}^* \to Z^*_q$ 和 $H_0:\{0,1\}^* \to G_1$ 为 Hash 函数，分别将任意比特串映射为 $Z^*_q$ 中的整数和群 $G_1$ 中的点。$Signer$ 选择 $x \leftarrow {_R}Z^*_q$ 作为自己的私钥，将 $P_{pub} \leftarrow xP$ 公开作为自己的公钥
     - $Sign$：
       - $User$ 和 $Signer$ 约定一个公共信息 $c$
       - $User$ 选择一个随机数 $r$，计算 $U \leftarrow H_0(m \| c)+r(H(c)P+P_{pub})$，将 $U$ 发送给 $Signer$
       - $Signer$ 利用自己的私钥 $x$、公共信息 $c$ 以及接收到的 $U$ 计算 $V=\frac{1}{H(c)+x}U$，将结果返回给 $User$
       - $User$ 计算 $S=V-rP$，输出消息签名对 $(m \| c,S)$
     - $Verify$：给定一个待验证的部分盲签名 $(m \| c,S)$，如果 $e(H(c)P+P_{pub},S)=e(P,H_0(m\|c))$，则签名验证者相信这是 $Signer$ 产生的有效签名 :book:（P78）

3. **群签名**

   - 概述：

     在一个群签名体制中，群体（Group）中的成员（Member）可代表整个群体进行匿名签名。一方面，验证者只能确定签名是由群体中的某个成员产生的，但不能确定是哪个成员；另一方面，在必要的时候群管理者（Group Manager）可以打开签名来揭示签名人的身份，使得签名人不能否认自己的签名行为。同时，在不打开群签名的条件下，任何人不能确定两个群签名是否为同一个成员产生的

   - 基本概念：

     在一个群签名方案中，一般包括一个群管理员和若干群成员，这些群成员构成的集合称为群。群管理员负责产生系统参数、群公钥、群私钥，同时要为群成员产生签名私钥或是群成员身份证书。群成员用自己掌握的签名私钥代表整个群体执行签名操作。在发生争端的情况下，群管理者能够从给定的群签名中识别出产生该签名的成员身份。有的群签名体制中，存在两个群管理者：一个负责为群成员颁发群成员私钥或群成员证书，另一个执行追踪功能。通常，一个群签名体制由下列算法组成：

     - $Setup$：产生群公钥、群成员的公钥和私钥以及群管理员用于打开签名的私钥
     - $Register$：一个新用户通过和群管理员的交互协议请求加入，协议执行结束后，合法的新成员完成身份注册并获得一个秘密密钥（有的方案中还会包含一个成员资格证书）
     - $Sign$：群签名产生算法，用群成员的私钥和成员资格证书对消息 $m$ 进行签名
     - $Verify$：验证消息 $m$ 的签名是否为合法的群签名
     - $Open$：群管理员输入消息、消息的签名和自己的私钥，运行打开算法以揭示签名者的真实身份

   - 安全性需求：

     - 正确性：一个合法的群成员按照签名产生算法产生的群签名一定能够通过签名验证算法
     - 不可伪造性（Unforgeability）：非群成员要产生一个通过验证算法的群签名在计算上是不可行的
     - 无关联性（Unlinkability）：在不打开签名的情况下，确定两个不同的群签名是否为同一个签名人所签是不可能的
     - 可跟踪性（Traceability）：一个正确的签名可以由群管理员揭示签名者的真实身份
     - 防陷害性（Exculpability）：包括群成员在内的任何成员都不能以其他群成员的名义产生合法的群签名
     - 抗联合攻击（Coalition-Resistance）：任意多个群成员勾结或与群管理员勾结都不能伪造其他群成员的签名

   - 应用场景：

     - 管理
     - 军事
     - 政治

   - 一个简单的群签名方案：

     - $Setup$：群管理者 $GM$ 为群中的每个成员分发一张秘密密钥表，这些表是互不相交的。$GM$ 将各个成员拥有的私钥汇总在一起，将这些私钥对应的公钥以一种随机的次序排成一张表，并将这个公钥表公开
     - $Sign$：每个群成员每次从自己的私钥表中选取一个没有使用过的私钥，利用这个密钥对消息产生签名
     - $Verify$：如果接收者要对某个群成员产生的群签名执行签名验证操作，他就用公钥表中的每个公钥去验证，只要发现有一个公钥使得签名验证通过，就说明这个签名是该群的合法签名
     - $Open$：在发生争端的情况下，由于群管理者知道所有群成员的私钥和公钥之间的对应关系，从而可以根据签名、公钥恢复出签名人的身份
     - 缺陷：
       - 没有讨论群成员动态加入问题
       - 每个群成员的任一私钥只能使用一次，否则，如果某个群成员使用自己的某个私钥 $x_i$ 同时对消息 $m_1$ 和 $m_2$ 执行签名操作，则验证者可以利用 $x_i$ 对应的公钥 $y_i$ 验证这两个签名有效，同时验证者可以确定这两个签名是由群中同一个成员产生的，丧失不可关联性
       - 由于群管理者知道每个群成员的私钥，所以他能够以任一群成员的名义产生有效群签名。不过，如果假设群管理者总是可信的，则可以认为 $GM$ 不会试图假冒群成员伪造群签名

   - 另一个简单的群签名体制：

     - 概述：该方案可以使得 $GM$ 不知道群成员的私钥。设 $p$ 是一大素数，在 $Z_p$ 上计算离散对数是不可行的，$g$ 是 $Z_p$ 的一个生成元。假设有 $n$ 个人构成了一个群，他们的秘密密钥分别为 $s_1,s_2,\cdots,s_n$，对应的公钥是 $y_i=g^{s_i} \pmod p,1 \leq i \leq n$
     - $Setup$：$GM$ 有一张群成员的名字与他们的公钥相对应的表。$GM$ 为群成员 $i$ 选取随机数 $r_i \in {_R}Z^*_p(1 \leq i \leq n)$，发送 $r_i$ 给对应的群成员，另将 $y^{r_i}_i(1 \leq i \leq n)$ 以一种随机的次序排成一张“公钥表”，并将这个表公开
     - $Sign$：每个群成员将 $r_is_i \bmod {(p-1)}$ 作为私钥，利用 ElGamal 型数字签名算法对消息产生群签名
     - $Verify$：如果接收者要对某个群成员产生的群签名执行签名验证操作，用公钥表中的每个公钥去验证，只要发现有一个“公钥”使得签名验证通过，就说明这个签名是该群的合法签名
     - $Open$：在发生争端的情况下，由于 $GM$ 知道 $r_i \in Z^*_p(1 \leq i \leq n)$，也知道所有群成员的公钥 $y_i$ 和名字之间的对应关系，从而可以根据签名、公钥恢复出签名人的身份
     - 优势：
       - $GM$ 不再拥有群成员执行签名时所使用的签名私钥
       - $GM$ 可以定期更新颁发给每个群成员的 $r_i \in Z^*_p(1 \leq i \leq n)$，使方案具有更大的灵活性
     - 缺陷：
       - 在新成员加入时，所有成员不得不改变他们的密钥，否则接收者能将旧的群成员和新的群成员区别开来

   - 短的群签名方案：Boneh 群签名方案 :book:（P82）

   - 成员撤销：

     - 概述：
       - 任何一个实用的群签名体制必须考虑到群成员动态流动的问题，即群成员不仅可以加入，还可以离开或在任何时间被群管理者取消签名权限
       - 所谓安全有效地撤销群成员，是指一种机制，使得某个群成员被撤销后，他拥有的私钥和成员证书不能再用于产生有效的群签名
       - 根据新成员加入或退出时群公钥或群成员私钥是否变化，可以将群签名方案分为动态群签名（需要更新群公钥或群成员私钥）和静态群签名（不需要更新群公钥或群成员私钥）
     - 例子：基于短的群签名方案的成员撤销方案 :book:（P84）

4. **环签名**

   - 概述：

     在一个环签名体制中，签名人可以随意挑选 $n-1$ 个人，这些人连同他自身构成一个含 $n$ 个人的集合，该集合被称为环。然后他可以用自己的私钥和其他 $n-1$ 个人的公钥一起对某个消息 $m$ 执行环签名操作，产生签名 $\sigma$。接到消息签名对 $(m,\sigma)$ 后，任一验证者执行环签名验证算法，如果签名有效则可以确信该签名是由这个环中某个签名者产生的，但他无法识别该签名人的身份。由此可见，环签名体制能够提供签名人匿名性。与群签名的匿名性不同，在环签名体制中不存在一个具有撤销匿名性的管理者，因此环签名体制提供的是一种不可撤销的匿名性。给定一个环签名，除了签名者自己外，任何人均无法获知产生该签名的签名人身份

   - 基本概念：

     给定一个环 $U=\{U_1,U_2,\cdots,U_n\}$，环中每个用户的公钥-私钥对为 $(pk_i,sk_i),i=1,2,\cdots,n$。不失一般性，假设 $U_k(1 \leq k \leq n)$ 是签名人。环签名体制包含以下算法：

     - $KeyGen$：密钥生成算法
     - $RingSign$：环签名产生算法。其输入是待签名的消息 $m$、环中所有成员的公钥 $pk_i(1 \leq i \leq n)$、真正签名人的私钥 $sk_k$；其输出就是 $U_k$ 对消息 $m$ 的环签名 $\sigma$，记做 $\sigma \leftarrow RingSign(m,pk_1,pk_2,\cdots,pk_n,sk_k)$
     - $RingVerify$：环签名验证算法。其输入是待验证的消息签名对 $(m,\sigma)$、环中所有成员的公钥；其输出为 $1$ 或 $0$，$1$ 表示接受该签名为有效，$0$ 表示签名无效，记做 $1 \or 0 \leftarrow RingVerify(m,\sigma,pk_1,pk_2,\cdots,pk_n)$

   - 安全性需求：

     - 正确性（Consistency）：环中的任一成员执行环签名算法后输出的签名都能通过体制中的签名验证算法
     - 匿名性（Anonymity）：给定一个环签名，则任一验证者不会以大于 $\frac{1}{n}$ 的概率识别产生该签名的真正签名人，其中 $n$ 为环中成员的个数
     - 不可伪造性（Unforgeability）：任意不在环中的用户不能有效地产生一个消息签名对 $(m,\sigma)$ 使得该签名被接受

     在满足了正确性、匿名性和不可伪造性后，就称该环签名体制是安全的。还有一些具有特殊性质的环签名，比如可链接性

     - 可链接性（Linkability）：如果环中的某个签名人产生了两个消息签名对 $(m_1,\sigma_1)$ 和 $(m_2,\sigma_2)$，则存在有效算法使得签名验证者可以确定这两个消息是由环中同一个签名人产生的（但他仍然不知道这个签名人的身份）

     具有可链接性的环签名体制还包括一个签名链接算法 $Link$：其输入是环中的两个签名，输出为 $0$（表示两个签名不是由同一个环成员产生的）或 $1$（表示两个签名是由同一个环成员产生的）

   - 应用场景：

     - 匿名举报
     - 匿名调查问卷：运用可链接性

   - 不具有可链接性的环签名：Boneh 环签名体制 :book:（P87）

   - 具有可链接性的环签名：:book:（P88）

5. **基于身份的数字签名（Identity Based Signature, IBS）**

   - 概述：

     为简化传统公钥密码系统的密钥管理问题，可以将用户的公开身份信息作为用户公钥，或是由该身份信息通过一个公开的算法计算出该用户的公钥；用户的私钥由一个被称为密钥生成器（Private Key Generator, PKG）的可信第三方生成，并安全地发送给用户。在基于身份的系统中，交互双方可以直接根据对方身份信息执行加密或是签名验证等密码操作。相对于传统的 PKI 技术，基于身份的系统无需复杂的公钥证书与认证，在应用中可以带来极大便利。

   - 定义：

     - $Setup$：系统初始化算法。该算法由 PKG 完成。输出系统的主密钥 $s$ 和系统参数 $param$。PKG 将系统参数公开发布，主密钥秘密保存
     - $Extract$：私钥提取算法。该算法由 PKG 完成。输入是系统中用户的身份信息 $ID \in \{0,1\}^*$。PKG 利用自己的主密钥 $s$ 和系统参数 $param$，计算出对应 $ID$ 的私钥 $d_{ID}$，最后将私钥秘密发送给该用户
     - $Sign$：签名算法。由签名人完成。输入是系统参数 $param$、签名者私钥 $d_ID$ 以及待签名的消息 $m$。输出即为签名人对该消息的签名 $\sigma$，记做 $\sigma \leftarrow Sign(param,d_{ID},m)$
     - $Verify$：签名验证算法。由任意验证者完成。输入是系统参数 $param$、签名者的身份信息 $ID$ 以及待验证的消息签名对 $(m,\sigma)$。输出为 $1$ 或 $0$，表示接受与拒绝，记做 $1 \or 0 \leftarrow Verify(param,ID,m,\sigma)$

   - 安全性需求：

     - 说一个数字签名体制是安全的，是指它具有在适应性选择消息攻击下的不可伪造性
     - 说一个基于身份的数字签名体制是安全的，是指它具有在适应性选择消息和选择身份攻击下的不可伪造性 :book:（P91）

   - 应用场景：

     - 电子邮件

   - 使用双线性映射技术的 IBS：:book:（P91）

   - 不使用双线性映射技术的 IBS：:book:（P92）

6. **思考题**

   - 试使用盲签名设计一个电子选举系统
   - 试使用部分盲签名设计一个电子支付系统
   - 试阐述动态群签名的涵义
   - 举例说明可链接环签名的用途

### 思考题

1.  针对加密算法进行破解是否是Dolev-Yao模型中包含的攻击者的能力？针对数字签名进行伪造呢？
2. A和B随机地从52张扑克中各抽岀一张扑克比较大小，由TTP发牌，只对牌进行签名，但如果不对牌面数字进行加密，可能遭遇什么攻击？ 
3. 如果由A对52张牌进行加密，在协议的设计中，为什么由B为A选一张牌？此外A对52张牌加密，是必须使用非对称密码体制吗？
4. 对称密码体制和非对称密码体制，哪种适合加密大量数据存储到云服务器上？
5. DES是一个分组加密算法，它的密钥长度是多少位，去除奇偶校验位后是多少位？
6. DES算法是？A.公开的  B.保密的
7. DES算法的密钥是？ A.公开的  B.保密的
8. DES算法使用的S盒代换实质是？A. 黑盒操作  B. 一种轮换    C.移位操作   D. 查表操作
9. 简述RSA加密算法（密钥生成、加密算法、解密算法）
10. 简述ElGamal加密算法 （加密算法和解密算法）
11. 以下算法，哪种或哪些可以使得多次加密同一个明文而产生的密文不同？A. RSA算法     B. ElGamal算法.    C DES算法
12. 公钥基础设施中，Alice的数字证书中的签名是由Bob生成，数字证书中包含的是Alice的公钥还是Bob的公钥？
13. 若Alice的证书是根证书，是由哪个实体为Alice签发证书？
14. 简述DH协议和其遭受的中间人攻击
15. 简述隐式认证、密钥确认和显示认证的概念
16. 试介绍2种常用的避免重放攻击的技术措施
17. 密钥建立协议所生成的密钥用作非对称加密算法还是对称加密算法？
18. 试介绍非对称加密算法和对称加密算法的优缺点
19. 试介绍如下协议遭受的攻击![image-20210111183521410](/Users/hyperzsb/Library/Application Support/typora-user-images/image-20210111183521410.png)
20. 哪种密码学技术既可以用于实现非否认性又可以实现数据完整性确认？
21. 下述协议遭受什么攻击，具体攻击流程是？![image-20210111183622091](/Users/hyperzsb/Library/Application Support/typora-user-images/image-20210111183622091.png)
22.  群签名的应用场景
23.  环签名的应用场景
24.  动态群签名的概念